File "./matrix-handshake-encryption-protocol.pv", line 216, characters 6-18:
Warning: identifier cipher_text_A rebound.
File "./matrix-handshake-encryption-protocol.pv", line 231, characters 13-25:
Warning: identifier cipher_text_B rebound.
File "./matrix-handshake-encryption-protocol.pv", line 235, characters 7-13:
Warning: identifier rootKey rebound.
File "./matrix-handshake-encryption-protocol.pv", line 235, characters 21-28:
Warning: identifier chainKey rebound.
File "./matrix-handshake-encryption-protocol.pv", line 237, characters 6-13:
Warning: identifier chainKey rebound.
File "./matrix-handshake-encryption-protocol.pv", line 239, characters 6-11:
Warning: identifier msgKey rebound.
File "./matrix-handshake-encryption-protocol.pv", line 241, characters 7-12:
Warning: identifier aesKey rebound.
File "./matrix-handshake-encryption-protocol.pv", line 241, characters 20-26:
Warning: identifier hmacKey rebound.
File "./matrix-handshake-encryption-protocol.pv", line 241, characters 34-38:
Warning: identifier aesIV rebound.
File "./matrix-handshake-encryption-protocol.pv", line 242, characters 6-17:
Warning: identifier plain_text_B rebound.
File "./matrix-handshake-encryption-protocol.pv", line 253, characters 13-25:
Warning: identifier cipher_text_A rebound.
File "./matrix-handshake-encryption-protocol.pv", line 260, characters 13-25:
Warning: identifier cipher_text_B rebound.
File "./matrix-handshake-encryption-protocol.pv", line 274, characters 13-25:
Warning: identifier cipher_text_A rebound.
File "./matrix-handshake-encryption-protocol.pv", line 281, characters 13-25:
Warning: identifier cipher_text_B rebound.
File "./matrix-handshake-encryption-protocol.pv", line 304, characters 13-25:
Warning: identifier cipher_text_A rebound.
File "./matrix-handshake-encryption-protocol.pv", line 308, characters 6-17:
Warning: identifier plain_text_A rebound.
File "./matrix-handshake-encryption-protocol.pv", line 317, characters 7-13:
Warning: identifier rootKey rebound.
File "./matrix-handshake-encryption-protocol.pv", line 317, characters 21-28:
Warning: identifier chainKey rebound.
File "./matrix-handshake-encryption-protocol.pv", line 319, characters 6-13:
Warning: identifier chainKey rebound.
File "./matrix-handshake-encryption-protocol.pv", line 321, characters 6-11:
Warning: identifier msgKey rebound.
File "./matrix-handshake-encryption-protocol.pv", line 324, characters 7-12:
Warning: identifier aesKey rebound.
File "./matrix-handshake-encryption-protocol.pv", line 324, characters 20-26:
Warning: identifier hmacKey rebound.
File "./matrix-handshake-encryption-protocol.pv", line 324, characters 34-38:
Warning: identifier aesIV rebound.
File "./matrix-handshake-encryption-protocol.pv", line 325, characters 6-18:
Warning: identifier cipher_text_B rebound.
Linear part:
sca(x,sca(y,P)) = sca(y,sca(x,P))
Completing equations...
Completed equations:
sca(x,sca(y,P)) = sca(y,sca(x,P))
Convergent part:
first_part2(concat2(b1,b2)) = b1
first_part3(concat3(b1,b2,b3)) = b1
Completing equations...
Completed equations:
first_part3(concat3(b1,b2,b3)) = b1
first_part2(concat2(b1,b2)) = b1
Process 0 (that is, the initial process):
{1}new skey_A_I: skey;
{2}new skey_B_I: skey;
(
    {3}!
    {4}let skey_A_I_1: skey = skey_A_I in
    {5}new skey_A_E: skey;
    {6}let pk_A_I: pkey = pk(skey_A_I_1) in
    {7}let pk_A_E: pkey = pk(skey_A_E) in
    {8}event evClientAliceSendKeys(pk_A_I,pk_A_E);
    {9}out(ch_c2s, (pk_A_I,pk_A_E));
    {10}in(ch_s2c, (pk_B_I: pkey,pk_B_E: pkey));
    {11}event evClientAliceReceiveKeys(pk_B_I,pk_B_E);
    {12}let ecdhkey_AB_1: G = sca(skey_A_I_1,pk_B_E) in
    {13}let sk_E_local: skey = skey_A_E in
    {14}let ecdhkey_AB_2: G = sca(sk_E_local,pk_B_I) in
    {15}let sk_E_local_1: skey = skey_A_E in
    {16}let ecdhkey_AB_3: G = sca(sk_E_local_1,pk_B_E) in
    {17}let SharedSecret_AB: bitstring = concat3(ecdhkey_AB_1,ecdhkey_AB_2,ecdhkey_AB_3) in
    {18}event evClientAliceCalcShareSecret(SharedSecret_AB);
    {19}insert table1_client_alice(skey_A_I_1,skey_A_E,pk_A_I,pk_A_E,pk_B_I,pk_B_E,SharedSecret_AB)
) | (
    {20}!
    {21}in(ch_c2s, (pk_A_I_1: pkey,pk_A_E_1: pkey));
    {22}out(ch_s2s, (pk_A_I_1,pk_A_E_1));
    {23}in(ch_s2s, (pk_B_I_1: pkey,pk_B_E_1: pkey));
    {24}out(ch_s2c, (pk_B_I_1,pk_B_E_1))
) | (
    {25}!
    {26}in(ch_s2s, (pk_A_I_2: pkey,pk_A_E_2: pkey));
    {27}out(ch_s2c, (pk_A_I_2,pk_A_E_2));
    {28}in(ch_c2s, (pk_B_I_2: pkey,pk_B_E_2: pkey));
    {29}out(ch_s2s, (pk_B_I_2,pk_B_E_2))
) | (
    {30}!
    {31}let skey_B_I_1: skey = skey_B_I in
    {32}new skey_B_E: skey;
    {33}in(ch_s2c, (pk_A_I_3: pkey,pk_A_E_3: pkey));
    {34}event evClientBobReceiveKeys(pk_A_I_3,pk_A_E_3);
    {35}let pk_B_I_3: pkey = pk(skey_B_I_1) in
    {36}let pk_B_E_3: pkey = pk(skey_B_E) in
    {37}event evClientBobSendKeys(pk_B_I_3,pk_B_E_3);
    {38}out(ch_c2s, (pk_B_I_3,pk_B_E_3));
    {39}let ecdhkey_AB: G = sca(skey_B_I_1,pk_A_E_3) in
    {40}let sk_E_local_2: skey = skey_B_E in
    {41}let ecdhkey_AB_4: G = sca(sk_E_local_2,pk_A_I_3) in
    {42}let sk_E_local_3: skey = skey_B_E in
    {43}let ecdhkey_AB_5: G = sca(sk_E_local_3,pk_A_E_3) in
    {44}let SharedSecret_BA: bitstring = concat3(ecdhkey_AB,ecdhkey_AB_4,ecdhkey_AB_5) in
    {45}event evClientBobCalcShareSecret(SharedSecret_BA);
    {46}insert table1_client_bob(skey_B_I_1,skey_B_E,pk_B_I_3,pk_B_E_3,pk_A_I_3,pk_A_E_3,SharedSecret_BA)
) | (
    {47}!
    {83}get table1_client_alice(skey_A_I_2: skey,skey_A_E_1: skey,pk_A_I_4: pkey,pk_A_E_4: pkey,pk_B_I_4: pkey,pk_B_E_4: pkey,SharedSecret_AB_1: key) in
    {48}let SALT_1: bitstring = SALT in
    {49}let INFO_1: bitstring = INFO in
    {50}let LENGTH_1: nat = 64 in
    {51}let OKM: bitstring = HKDF(SALT_1,SharedSecret_AB_1,INFO_1,LENGTH_1) in
    {52}let (rootKey: key,chainKey: key) = (fist256bit(OKM),next256bit(OKM)) in
    {53}let ratchetKey_A: skey = rk(skey_A_I_2) in
    {54}let msgKey: key = HMAC_SHA256(chainKey,PADDING_1) in
    {55}let SALT_2: bitstring = SALT in
    {56}let INFO_2: bitstring = INFO in
    {57}let LENGTH_2: nat = 80 in
    {58}let OKM_1: bitstring = HKDF(SALT_2,msgKey,INFO_2,LENGTH_2) in
    {59}let (aesKey: key,hmacKey: key,aesIV: iv) = (fist256bit(OKM_1),next256bit(OKM_1),last128bit(OKM_1)) in
    {60}let cipher_text_A_1: bitstring = senccbc(plain_text_A,aesKey,aesIV) in
    {61}event evClientAliceSendRatchetKey(pk(ratchetKey_A));
    {62}out(ch_c2s, pk(ratchetKey_A));
    {63}event evClientAliceSendCipertext(cipher_text_A_1);
    {64}out(ch_c2s, cipher_text_A_1);
    {65}in(ch_s2c, pk_ratchetKey_B: pkey);
    {66}event evClientAliceReceiveRatchetKey(pk_ratchetKey_B);
    {67}in(ch_s2c, cipher_text_B_1: bitstring);
    {68}event evClientAliceReceiveCipertext(cipher_text_B_1);
    {69}let IKM: key = sca(ratchetKey_A,pk_ratchetKey_B) in
    {70}let INFO_3: bitstring = INFO in
    {71}let LENGTH_3: nat = 64 in
    {72}let OKM_2: bitstring = HKDF(rootKey,IKM,INFO_3,LENGTH_3) in
    {73}let (rootKey_1: key,chainKey_1: key) = (fist256bit(OKM_2),next256bit(OKM_2)) in
    {74}let chainKey_2: key = HMAC_SHA256(chainKey_1,PADDING_2) in
    {75}let msgKey_1: key = HMAC_SHA256(chainKey_2,PADDING_1) in
    {76}let SALT_3: bitstring = SALT in
    {77}let INFO_4: bitstring = INFO in
    {78}let LENGTH_4: nat = 80 in
    {79}let OKM_3: bitstring = HKDF(SALT_3,msgKey_1,INFO_4,LENGTH_4) in
    {80}let (aesKey_1: key,hmacKey_1: key,aesIV_1: iv) = (fist256bit(OKM_3),next256bit(OKM_3),last128bit(OKM_3)) in
    {81}let plain_text_B_1: bitstring = sdeccbc(cipher_text_B_1,aesKey_1,aesIV_1) in
    {82}event evClientAliceDecryptPlaintext(plain_text_B_1)
) | (
    {84}!
    {93}get table1_server_alice(pk_A_I_5: pkey,pk_A_E_5: pkey,pk_B_I_5: pkey,pk_B_E_5: pkey) in
    {85}in(ch_c2s, cipher_text_A_2: bitstring);
    {86}in(ch_c2s, pk_ratchetKey_A: pkey);
    {87}out(ch_s2s, cipher_text_A_2);
    {88}out(ch_s2s, pk_ratchetKey_A);
    {89}in(ch_s2s, cipher_text_B_2: bitstring);
    {90}in(ch_s2s, pk_ratchetKey_B_1: pkey);
    {91}out(ch_s2c, cipher_text_B_2);
    {92}out(ch_s2c, pk_ratchetKey_B_1)
) | (
    {94}!
    {103}get table1_server_bob(pk_B_I_6: pkey,pk_B_E_6: pkey,pk_A_I_6: pkey,pk_A_E_6: pkey) in
    {95}in(ch_s2s, cipher_text_A_3: bitstring);
    {96}in(ch_s2s, pk_ratchetKey_A_1: pkey);
    {97}out(ch_c2s, cipher_text_A_3);
    {98}out(ch_c2s, pk_ratchetKey_A_1);
    {99}in(ch_c2s, cipher_text_B_3: bitstring);
    {100}in(ch_c2s, pk_ratchetKey_B_2: pkey);
    {101}out(ch_s2s, cipher_text_B_3);
    {102}out(ch_s2s, pk_ratchetKey_B_2)
) | (
    {104}!
    {140}get table1_client_bob(skey_B_I_2: skey,skey_B_E_1: skey,pk_B_I_7: pkey,pk_B_E_7: pkey,pk_A_I_7: pkey,pk_A_E_7: pkey,SharedSecret_BA_1: key) in
    {105}let SALT_4: bitstring = SALT in
    {106}let INFO_5: bitstring = INFO in
    {107}let LENGTH_5: nat = 64 in
    {108}let OKM_4: bitstring = HKDF(SALT_4,SharedSecret_BA_1,INFO_5,LENGTH_5) in
    {109}let (rootKey_2: key,chainKey_3: key) = (fist256bit(OKM_4),next256bit(OKM_4)) in
    {110}let ratchetKey_B: skey = rk(skey_B_I_2) in
    {111}let msgKey_2: key = HMAC_SHA256(chainKey_3,PADDING_1) in
    {112}in(ch_s2c, pk_ratchetKey_A_2: pkey);
    {113}event evClientBobReceiveRatchetKey(pk_ratchetKey_A_2);
    {114}in(ch_s2c, cipher_text_A_4: bitstring);
    {115}event evClientBobReceiveCipertext(cipher_text_A_4);
    {116}let SALT_5: bitstring = SALT in
    {117}let INFO_6: bitstring = INFO in
    {118}let LENGTH_6: nat = 80 in
    {119}let OKM_5: bitstring = HKDF(SALT_5,msgKey_2,INFO_6,LENGTH_6) in
    {120}let (aesKey_2: key,hmacKey_2: key,aesIV_2: iv) = (fist256bit(OKM_5),next256bit(OKM_5),last128bit(OKM_5)) in
    {121}let plain_text_A_1: bitstring = sdeccbc(cipher_text_A_4,aesKey_2,aesIV_2) in
    {122}event evClientBobDecryptPlaintext(plain_text_A_1);
    {123}let IKM_1: key = sca(ratchetKey_B,pk_ratchetKey_A_2) in
    {124}let INFO_7: bitstring = INFO in
    {125}let LENGTH_7: nat = 64 in
    {126}let OKM_6: bitstring = HKDF(rootKey_2,IKM_1,INFO_7,LENGTH_7) in
    {127}let (rootKey_3: key,chainKey_4: key) = (fist256bit(OKM_6),next256bit(OKM_6)) in
    {128}let chainKey_5: key = HMAC_SHA256(chainKey_4,PADDING_2) in
    {129}let msgKey_3: key = HMAC_SHA256(chainKey_5,PADDING_1) in
    {130}let SALT_6: bitstring = SALT in
    {131}let INFO_8: bitstring = INFO in
    {132}let LENGTH_8: nat = 80 in
    {133}let OKM_7: bitstring = HKDF(SALT_6,msgKey_3,INFO_8,LENGTH_8) in
    {134}let (aesKey_3: key,hmacKey_3: key,aesIV_3: iv) = (fist256bit(OKM_7),next256bit(OKM_7),last128bit(OKM_7)) in
    {135}let cipher_text_B_4: bitstring = senccbc(plain_text_B,aesKey_3,aesIV_3) in
    {136}event evClientBobSendRatchetKey(pk(ratchetKey_B));
    {137}out(ch_c2s, pk(ratchetKey_B));
    {138}event evClientBobSendCipertext(cipher_text_B_4);
    {139}out(ch_c2s, cipher_text_B_4)
)

--  Process 1 (that is, process 0, with let moved downwards):
{1}new skey_A_I: skey;
{2}new skey_B_I: skey;
(
    {3}!
    {5}new skey_A_E: skey;
    {7}let pk_A_E: pkey = pk(skey_A_E) in
    {4}let skey_A_I_1: skey = skey_A_I in
    {6}let pk_A_I: pkey = pk(skey_A_I_1) in
    {8}event evClientAliceSendKeys(pk_A_I,pk_A_E);
    {9}out(ch_c2s, (pk_A_I,pk_A_E));
    {10}in(ch_s2c, (pk_B_I: pkey,pk_B_E: pkey));
    {11}event evClientAliceReceiveKeys(pk_B_I,pk_B_E);
    {15}let sk_E_local_1: skey = skey_A_E in
    {16}let ecdhkey_AB_3: G = sca(sk_E_local_1,pk_B_E) in
    {13}let sk_E_local: skey = skey_A_E in
    {14}let ecdhkey_AB_2: G = sca(sk_E_local,pk_B_I) in
    {12}let ecdhkey_AB_1: G = sca(skey_A_I_1,pk_B_E) in
    {17}let SharedSecret_AB: bitstring = concat3(ecdhkey_AB_1,ecdhkey_AB_2,ecdhkey_AB_3) in
    {18}event evClientAliceCalcShareSecret(SharedSecret_AB);
    {19}insert table1_client_alice(skey_A_I_1,skey_A_E,pk_A_I,pk_A_E,pk_B_I,pk_B_E,SharedSecret_AB)
) | (
    {20}!
    {21}in(ch_c2s, (pk_A_I_1: pkey,pk_A_E_1: pkey));
    {22}out(ch_s2s, (pk_A_I_1,pk_A_E_1));
    {23}in(ch_s2s, (pk_B_I_1: pkey,pk_B_E_1: pkey));
    {24}out(ch_s2c, (pk_B_I_1,pk_B_E_1))
) | (
    {25}!
    {26}in(ch_s2s, (pk_A_I_2: pkey,pk_A_E_2: pkey));
    {27}out(ch_s2c, (pk_A_I_2,pk_A_E_2));
    {28}in(ch_c2s, (pk_B_I_2: pkey,pk_B_E_2: pkey));
    {29}out(ch_s2s, (pk_B_I_2,pk_B_E_2))
) | (
    {30}!
    {32}new skey_B_E: skey;
    {33}in(ch_s2c, (pk_A_I_3: pkey,pk_A_E_3: pkey));
    {34}event evClientBobReceiveKeys(pk_A_I_3,pk_A_E_3);
    {36}let pk_B_E_3: pkey = pk(skey_B_E) in
    {31}let skey_B_I_1: skey = skey_B_I in
    {35}let pk_B_I_3: pkey = pk(skey_B_I_1) in
    {37}event evClientBobSendKeys(pk_B_I_3,pk_B_E_3);
    {38}out(ch_c2s, (pk_B_I_3,pk_B_E_3));
    {42}let sk_E_local_3: skey = skey_B_E in
    {43}let ecdhkey_AB_5: G = sca(sk_E_local_3,pk_A_E_3) in
    {40}let sk_E_local_2: skey = skey_B_E in
    {41}let ecdhkey_AB_4: G = sca(sk_E_local_2,pk_A_I_3) in
    {39}let ecdhkey_AB: G = sca(skey_B_I_1,pk_A_E_3) in
    {44}let SharedSecret_BA: bitstring = concat3(ecdhkey_AB,ecdhkey_AB_4,ecdhkey_AB_5) in
    {45}event evClientBobCalcShareSecret(SharedSecret_BA);
    {46}insert table1_client_bob(skey_B_I_1,skey_B_E,pk_B_I_3,pk_B_E_3,pk_A_I_3,pk_A_E_3,SharedSecret_BA)
) | (
    {47}!
    {83}get table1_client_alice(skey_A_I_2: skey,skey_A_E_1: skey,pk_A_I_4: pkey,pk_A_E_4: pkey,pk_B_I_4: pkey,pk_B_E_4: pkey,SharedSecret_AB_1: key) in
    {50}let LENGTH_1: nat = 64 in
    {49}let INFO_1: bitstring = INFO in
    {48}let SALT_1: bitstring = SALT in
    {51}let OKM: bitstring = HKDF(SALT_1,SharedSecret_AB_1,INFO_1,LENGTH_1) in
    {52}let (rootKey: key,chainKey: key) = (fist256bit(OKM),next256bit(OKM)) in
    {57}let LENGTH_2: nat = 80 in
    {56}let INFO_2: bitstring = INFO in
    {55}let SALT_2: bitstring = SALT in
    {54}let msgKey: key = HMAC_SHA256(chainKey,PADDING_1) in
    {58}let OKM_1: bitstring = HKDF(SALT_2,msgKey,INFO_2,LENGTH_2) in
    {59}let (aesKey: key,hmacKey: key,aesIV: iv) = (fist256bit(OKM_1),next256bit(OKM_1),last128bit(OKM_1)) in
    {53}let ratchetKey_A: skey = rk(skey_A_I_2) in
    {61}event evClientAliceSendRatchetKey(pk(ratchetKey_A));
    {62}out(ch_c2s, pk(ratchetKey_A));
    {60}let cipher_text_A_1: bitstring = senccbc(plain_text_A,aesKey,aesIV) in
    {63}event evClientAliceSendCipertext(cipher_text_A_1);
    {64}out(ch_c2s, cipher_text_A_1);
    {65}in(ch_s2c, pk_ratchetKey_B: pkey);
    {66}event evClientAliceReceiveRatchetKey(pk_ratchetKey_B);
    {67}in(ch_s2c, cipher_text_B_1: bitstring);
    {68}event evClientAliceReceiveCipertext(cipher_text_B_1);
    {71}let LENGTH_3: nat = 64 in
    {70}let INFO_3: bitstring = INFO in
    {69}let IKM: key = sca(ratchetKey_A,pk_ratchetKey_B) in
    {72}let OKM_2: bitstring = HKDF(rootKey,IKM,INFO_3,LENGTH_3) in
    {73}let (rootKey_1: key,chainKey_1: key) = (fist256bit(OKM_2),next256bit(OKM_2)) in
    {78}let LENGTH_4: nat = 80 in
    {77}let INFO_4: bitstring = INFO in
    {76}let SALT_3: bitstring = SALT in
    {74}let chainKey_2: key = HMAC_SHA256(chainKey_1,PADDING_2) in
    {75}let msgKey_1: key = HMAC_SHA256(chainKey_2,PADDING_1) in
    {79}let OKM_3: bitstring = HKDF(SALT_3,msgKey_1,INFO_4,LENGTH_4) in
    {80}let (aesKey_1: key,hmacKey_1: key,aesIV_1: iv) = (fist256bit(OKM_3),next256bit(OKM_3),last128bit(OKM_3)) in
    {81}let plain_text_B_1: bitstring = sdeccbc(cipher_text_B_1,aesKey_1,aesIV_1) in
    {82}event evClientAliceDecryptPlaintext(plain_text_B_1)
) | (
    {84}!
    {93}get table1_server_alice(pk_A_I_5: pkey,pk_A_E_5: pkey,pk_B_I_5: pkey,pk_B_E_5: pkey) in
    {85}in(ch_c2s, cipher_text_A_2: bitstring);
    {86}in(ch_c2s, pk_ratchetKey_A: pkey);
    {87}out(ch_s2s, cipher_text_A_2);
    {88}out(ch_s2s, pk_ratchetKey_A);
    {89}in(ch_s2s, cipher_text_B_2: bitstring);
    {90}in(ch_s2s, pk_ratchetKey_B_1: pkey);
    {91}out(ch_s2c, cipher_text_B_2);
    {92}out(ch_s2c, pk_ratchetKey_B_1)
) | (
    {94}!
    {103}get table1_server_bob(pk_B_I_6: pkey,pk_B_E_6: pkey,pk_A_I_6: pkey,pk_A_E_6: pkey) in
    {95}in(ch_s2s, cipher_text_A_3: bitstring);
    {96}in(ch_s2s, pk_ratchetKey_A_1: pkey);
    {97}out(ch_c2s, cipher_text_A_3);
    {98}out(ch_c2s, pk_ratchetKey_A_1);
    {99}in(ch_c2s, cipher_text_B_3: bitstring);
    {100}in(ch_c2s, pk_ratchetKey_B_2: pkey);
    {101}out(ch_s2s, cipher_text_B_3);
    {102}out(ch_s2s, pk_ratchetKey_B_2)
) | (
    {104}!
    {140}get table1_client_bob(skey_B_I_2: skey,skey_B_E_1: skey,pk_B_I_7: pkey,pk_B_E_7: pkey,pk_A_I_7: pkey,pk_A_E_7: pkey,SharedSecret_BA_1: key) in
    {107}let LENGTH_5: nat = 64 in
    {106}let INFO_5: bitstring = INFO in
    {105}let SALT_4: bitstring = SALT in
    {108}let OKM_4: bitstring = HKDF(SALT_4,SharedSecret_BA_1,INFO_5,LENGTH_5) in
    {109}let (rootKey_2: key,chainKey_3: key) = (fist256bit(OKM_4),next256bit(OKM_4)) in
    {112}in(ch_s2c, pk_ratchetKey_A_2: pkey);
    {113}event evClientBobReceiveRatchetKey(pk_ratchetKey_A_2);
    {114}in(ch_s2c, cipher_text_A_4: bitstring);
    {115}event evClientBobReceiveCipertext(cipher_text_A_4);
    {118}let LENGTH_6: nat = 80 in
    {117}let INFO_6: bitstring = INFO in
    {116}let SALT_5: bitstring = SALT in
    {111}let msgKey_2: key = HMAC_SHA256(chainKey_3,PADDING_1) in
    {119}let OKM_5: bitstring = HKDF(SALT_5,msgKey_2,INFO_6,LENGTH_6) in
    {120}let (aesKey_2: key,hmacKey_2: key,aesIV_2: iv) = (fist256bit(OKM_5),next256bit(OKM_5),last128bit(OKM_5)) in
    {121}let plain_text_A_1: bitstring = sdeccbc(cipher_text_A_4,aesKey_2,aesIV_2) in
    {122}event evClientBobDecryptPlaintext(plain_text_A_1);
    {125}let LENGTH_7: nat = 64 in
    {124}let INFO_7: bitstring = INFO in
    {110}let ratchetKey_B: skey = rk(skey_B_I_2) in
    {123}let IKM_1: key = sca(ratchetKey_B,pk_ratchetKey_A_2) in
    {126}let OKM_6: bitstring = HKDF(rootKey_2,IKM_1,INFO_7,LENGTH_7) in
    {127}let (rootKey_3: key,chainKey_4: key) = (fist256bit(OKM_6),next256bit(OKM_6)) in
    {132}let LENGTH_8: nat = 80 in
    {131}let INFO_8: bitstring = INFO in
    {130}let SALT_6: bitstring = SALT in
    {128}let chainKey_5: key = HMAC_SHA256(chainKey_4,PADDING_2) in
    {129}let msgKey_3: key = HMAC_SHA256(chainKey_5,PADDING_1) in
    {133}let OKM_7: bitstring = HKDF(SALT_6,msgKey_3,INFO_8,LENGTH_8) in
    {134}let (aesKey_3: key,hmacKey_3: key,aesIV_3: iv) = (fist256bit(OKM_7),next256bit(OKM_7),last128bit(OKM_7)) in
    {136}event evClientBobSendRatchetKey(pk(ratchetKey_B));
    {137}out(ch_c2s, pk(ratchetKey_B));
    {135}let cipher_text_B_4: bitstring = senccbc(plain_text_B,aesKey_3,aesIV_3) in
    {138}event evClientBobSendCipertext(cipher_text_B_4);
    {139}out(ch_c2s, cipher_text_B_4)
)

-- Query event(evClientBobReceiveKeys(pk_I,pk_E)) ==> event(evClientAliceSendKeys(pk_I,pk_E)) in process 1.
Translating the process into Horn clauses...
Completing...
200 rules inserted. Base: 188 rules (66 with conclusion selected). Queue: 32 rules.
Starting query event(evClientBobReceiveKeys(pk_I,pk_E)) ==> event(evClientAliceSendKeys(pk_I,pk_E))
goal reachable: attacker(pk_I) && attacker(pk_E) -> event(evClientBobReceiveKeys(pk_I,pk_E))

Derivation:

1. We assume as hypothesis that
attacker(pk_E).

2. We assume as hypothesis that
attacker(pk_I).

3. By 2, the attacker may know pk_I.
By 1, the attacker may know pk_E.
Using the function 2-tuple the attacker may obtain (pk_I,pk_E).
attacker((pk_I,pk_E)).

4. The message (pk_I,pk_E) that the attacker may have by 3 may be received at input {33}.
So event evClientBobReceiveKeys(pk_I,pk_E) may be executed at {34}.
event(evClientBobReceiveKeys(pk_I,pk_E)).

5. By 4, event(evClientBobReceiveKeys(pk_I,pk_E)).
The goal is reached, represented in the following fact:
event(evClientBobReceiveKeys(pk_I,pk_E)).


A more detailed output of the traces is available with
  set traceDisplay = long.

new skey_A_I: skey creating skey_A_I_3 at {1}

new skey_B_I: skey creating skey_B_I_3 at {2}

new skey_B_E: skey creating skey_B_E_2 at {32} in copy a

in(ch_s2c, (a_1,a_2)) at {33} in copy a

event evClientBobReceiveKeys(a_1,a_2) at {34} in copy a (goal)

The event evClientBobReceiveKeys(a_1,a_2) is executed at {34} in copy a.
A trace has been found.
RESULT event(evClientBobReceiveKeys(pk_I,pk_E)) ==> event(evClientAliceSendKeys(pk_I,pk_E)) is false.
-- Query event(evClientAliceReceiveKeys(pk_I,pk_E)) ==> event(evClientBobSendKeys(pk_I,pk_E)) in process 1.
Translating the process into Horn clauses...
Completing...
200 rules inserted. Base: 188 rules (66 with conclusion selected). Queue: 31 rules.
Starting query event(evClientAliceReceiveKeys(pk_I,pk_E)) ==> event(evClientBobSendKeys(pk_I,pk_E))
goal reachable: attacker(pk_I) && attacker(pk_E) -> event(evClientAliceReceiveKeys(pk_I,pk_E))

Derivation:

1. We assume as hypothesis that
attacker(pk_E).

2. We assume as hypothesis that
attacker(pk_I).

3. By 2, the attacker may know pk_I.
By 1, the attacker may know pk_E.
Using the function 2-tuple the attacker may obtain (pk_I,pk_E).
attacker((pk_I,pk_E)).

4. The message (pk_I,pk_E) that the attacker may have by 3 may be received at input {10}.
So event evClientAliceReceiveKeys(pk_I,pk_E) may be executed at {11}.
event(evClientAliceReceiveKeys(pk_I,pk_E)).

5. By 4, event(evClientAliceReceiveKeys(pk_I,pk_E)).
The goal is reached, represented in the following fact:
event(evClientAliceReceiveKeys(pk_I,pk_E)).


A more detailed output of the traces is available with
  set traceDisplay = long.

new skey_A_I: skey creating skey_A_I_3 at {1}

new skey_B_I: skey creating skey_B_I_3 at {2}

new skey_A_E: skey creating skey_A_E_2 at {5} in copy a

event evClientAliceSendKeys(pk(skey_A_I_3),pk(skey_A_E_2)) at {8} in copy a

out(ch_c2s, (~M,~M_1)) with ~M = pk(skey_A_I_3), ~M_1 = pk(skey_A_E_2) at {9} in copy a

in(ch_s2c, (a_1,a_2)) at {10} in copy a

event evClientAliceReceiveKeys(a_1,a_2) at {11} in copy a (goal)

The event evClientAliceReceiveKeys(a_1,a_2) is executed at {11} in copy a.
A trace has been found.
RESULT event(evClientAliceReceiveKeys(pk_I,pk_E)) ==> event(evClientBobSendKeys(pk_I,pk_E)) is false.
-- Query event(evClientAliceCalcShareSecret(SharedSecret)) ==> event(evClientBobSendKeys(pk_I,pk_E)) in process 1.
Translating the process into Horn clauses...
Completing...
200 rules inserted. Base: 188 rules (73 with conclusion selected). Queue: 11 rules.
Starting query event(evClientAliceCalcShareSecret(SharedSecret)) ==> event(evClientBobSendKeys(pk_I,pk_E))
goal reachable: attacker(y) && attacker(pk_B_E_8) -> event(evClientAliceCalcShareSecret(concat3(sca(skey_A_I[],pk_B_E_8),sca(y,sca(skey_A_E_2,P)),sca(skey_A_E_2,pk_B_E_8))))
Abbreviations:
skey_A_E_2 = skey_A_E[!1 = @sid]

Derivation:
Abbreviations:
skey_A_E_2 = skey_A_E[!1 = @sid]

1. We assume as hypothesis that
attacker(pk_B_E_8).

2. Using the function P the attacker may obtain P.
attacker(P).

3. We assume as hypothesis that
attacker(y).

4. By 3, the attacker may know y.
By 2, the attacker may know P.
Using the function sca the attacker may obtain sca(y,P).
attacker(sca(y,P)).

5. By 4, the attacker may know sca(y,P).
By 1, the attacker may know pk_B_E_8.
Using the function 2-tuple the attacker may obtain (sca(y,P),pk_B_E_8).
attacker((sca(y,P),pk_B_E_8)).

6. The message (sca(y,P),pk_B_E_8) that the attacker may have by 5 may be received at input {10}.
So event evClientAliceCalcShareSecret(concat3(sca(skey_A_I[],pk_B_E_8),sca(y,sca(skey_A_E_2,P)),sca(skey_A_E_2,pk_B_E_8))) may be executed at {18}.
event(evClientAliceCalcShareSecret(concat3(sca(skey_A_I[],pk_B_E_8),sca(y,sca(skey_A_E_2,P)),sca(skey_A_E_2,pk_B_E_8)))).

7. By 6, event(evClientAliceCalcShareSecret(concat3(sca(skey_A_I[],pk_B_E_8),sca(y,sca(skey_A_E_2,P)),sca(skey_A_E_2,pk_B_E_8)))).
The goal is reached, represented in the following fact:
event(evClientAliceCalcShareSecret(concat3(sca(skey_A_I[],pk_B_E_8),sca(y,sca(skey_A_E_2,P)),sca(skey_A_E_2,pk_B_E_8)))).


A more detailed output of the traces is available with
  set traceDisplay = long.

new skey_A_I: skey creating skey_A_I_3 at {1}

new skey_B_I: skey creating skey_B_I_3 at {2}

new skey_A_E: skey creating skey_A_E_3 at {5} in copy a

event evClientAliceSendKeys(pk(skey_A_I_3),pk(skey_A_E_3)) at {8} in copy a

out(ch_c2s, (~M,~M_1)) with ~M = pk(skey_A_I_3), ~M_1 = pk(skey_A_E_3) at {9} in copy a

in(ch_s2c, (sca(a_1,P),a_2)) at {10} in copy a

event evClientAliceReceiveKeys(sca(a_1,P),a_2) at {11} in copy a

event evClientAliceCalcShareSecret(concat3(sca(skey_A_I_3,a_2),sca(skey_A_E_3,sca(a_1,P)),sca(skey_A_E_3,a_2))) at {18} in copy a (goal)

The event evClientAliceCalcShareSecret(concat3(sca(skey_A_I_3,a_2),sca(a_1,sca(skey_A_E_3,P)),sca(skey_A_E_3,a_2))) is executed at {18} in copy a.
A trace has been found.
RESULT event(evClientAliceCalcShareSecret(SharedSecret)) ==> event(evClientBobSendKeys(pk_I,pk_E)) is false.
-- Query event(evClientBobCalcShareSecret(SharedSecret)) ==> event(evClientAliceSendKeys(pk_I,pk_E)) in process 1.
Translating the process into Horn clauses...
Completing...
200 rules inserted. Base: 188 rules (73 with conclusion selected). Queue: 11 rules.
Starting query event(evClientBobCalcShareSecret(SharedSecret)) ==> event(evClientAliceSendKeys(pk_I,pk_E))
goal reachable: attacker(y) && attacker(pk_A_E_8) -> event(evClientBobCalcShareSecret(concat3(sca(skey_B_I[],pk_A_E_8),sca(y,sca(skey_B_E_2,P)),sca(skey_B_E_2,pk_A_E_8))))
Abbreviations:
skey_B_E_2 = skey_B_E[!1 = @sid]

Derivation:
Abbreviations:
skey_B_E_2 = skey_B_E[!1 = @sid]

1. We assume as hypothesis that
attacker(pk_A_E_8).

2. Using the function P the attacker may obtain P.
attacker(P).

3. We assume as hypothesis that
attacker(y).

4. By 3, the attacker may know y.
By 2, the attacker may know P.
Using the function sca the attacker may obtain sca(y,P).
attacker(sca(y,P)).

5. By 4, the attacker may know sca(y,P).
By 1, the attacker may know pk_A_E_8.
Using the function 2-tuple the attacker may obtain (sca(y,P),pk_A_E_8).
attacker((sca(y,P),pk_A_E_8)).

6. The message (sca(y,P),pk_A_E_8) that the attacker may have by 5 may be received at input {33}.
So event evClientBobCalcShareSecret(concat3(sca(skey_B_I[],pk_A_E_8),sca(y,sca(skey_B_E_2,P)),sca(skey_B_E_2,pk_A_E_8))) may be executed at {45}.
event(evClientBobCalcShareSecret(concat3(sca(skey_B_I[],pk_A_E_8),sca(y,sca(skey_B_E_2,P)),sca(skey_B_E_2,pk_A_E_8)))).

7. By 6, event(evClientBobCalcShareSecret(concat3(sca(skey_B_I[],pk_A_E_8),sca(y,sca(skey_B_E_2,P)),sca(skey_B_E_2,pk_A_E_8)))).
The goal is reached, represented in the following fact:
event(evClientBobCalcShareSecret(concat3(sca(skey_B_I[],pk_A_E_8),sca(y,sca(skey_B_E_2,P)),sca(skey_B_E_2,pk_A_E_8)))).


A more detailed output of the traces is available with
  set traceDisplay = long.

new skey_A_I: skey creating skey_A_I_3 at {1}

new skey_B_I: skey creating skey_B_I_3 at {2}

new skey_B_E: skey creating skey_B_E_3 at {32} in copy a

in(ch_s2c, (sca(a_1,P),a_2)) at {33} in copy a

event evClientBobReceiveKeys(sca(a_1,P),a_2) at {34} in copy a

event evClientBobSendKeys(pk(skey_B_I_3),pk(skey_B_E_3)) at {37} in copy a

out(ch_c2s, (~M,~M_1)) with ~M = pk(skey_B_I_3), ~M_1 = pk(skey_B_E_3) at {38} in copy a

event evClientBobCalcShareSecret(concat3(sca(skey_B_I_3,a_2),sca(skey_B_E_3,sca(a_1,P)),sca(skey_B_E_3,a_2))) at {45} in copy a (goal)

The event evClientBobCalcShareSecret(concat3(sca(skey_B_I_3,a_2),sca(a_1,sca(skey_B_E_3,P)),sca(skey_B_E_3,a_2))) is executed at {45} in copy a.
A trace has been found.
RESULT event(evClientBobCalcShareSecret(SharedSecret)) ==> event(evClientAliceSendKeys(pk_I,pk_E)) is false.
-- Query event(evClientAliceReceiveRatchetKey(ratchetKey)) ==> event(evClientBobSendRatchetKey(ratchetKey)) in process 1.
Translating the process into Horn clauses...
Completing...
200 rules inserted. Base: 187 rules (66 with conclusion selected). Queue: 32 rules.
Starting query event(evClientAliceReceiveRatchetKey(ratchetKey)) ==> event(evClientBobSendRatchetKey(ratchetKey))
goal reachable: attacker(ratchetKey) -> event(evClientAliceReceiveRatchetKey(ratchetKey))

Derivation:
Abbreviations:
skey_A_E_2 = skey_A_E[!1 = @sid]

1. The attacker has some term pk_B_E_8.
attacker(pk_B_E_8).

2. The attacker has some term pk_B_I_8.
attacker(pk_B_I_8).

3. By 2, the attacker may know pk_B_I_8.
By 1, the attacker may know pk_B_E_8.
Using the function 2-tuple the attacker may obtain (pk_B_I_8,pk_B_E_8).
attacker((pk_B_I_8,pk_B_E_8)).

4. The message (pk_B_I_8,pk_B_E_8) that the attacker may have by 3 may be received at input {10}.
So the entry table1_client_alice(skey_A_I[],skey_A_E_2,pk(skey_A_I[]),pk(skey_A_E_2),pk_B_I_8,pk_B_E_8,concat3(sca(skey_A_I[],pk_B_E_8),sca(skey_A_E_2,pk_B_I_8),sca(skey_A_E_2,pk_B_E_8))) may be inserted in a table at insert {19}.
table(table1_client_alice(skey_A_I[],skey_A_E_2,pk(skey_A_I[]),pk(skey_A_E_2),pk_B_I_8,pk_B_E_8,concat3(sca(skey_A_I[],pk_B_E_8),sca(skey_A_E_2,pk_B_I_8),sca(skey_A_E_2,pk_B_E_8)))).

5. We assume as hypothesis that
attacker(ratchetKey).

6. The entry table1_client_alice(skey_A_I[],skey_A_E_2,pk(skey_A_I[]),pk(skey_A_E_2),pk_B_I_8,pk_B_E_8,concat3(sca(skey_A_I[],pk_B_E_8),sca(skey_A_E_2,pk_B_I_8),sca(skey_A_E_2,pk_B_E_8))) that may be in a table by 4 may be read at get {83}.
The message ratchetKey that the attacker may have by 5 may be received at input {65}.
So event evClientAliceReceiveRatchetKey(ratchetKey) may be executed at {66}.
event(evClientAliceReceiveRatchetKey(ratchetKey)).

7. By 6, event(evClientAliceReceiveRatchetKey(ratchetKey)).
The goal is reached, represented in the following fact:
event(evClientAliceReceiveRatchetKey(ratchetKey)).


A more detailed output of the traces is available with
  set traceDisplay = long.

new skey_A_I: skey creating skey_A_I_3 at {1}

new skey_B_I: skey creating skey_B_I_3 at {2}

new skey_A_E: skey creating skey_A_E_3 at {5} in copy a

event evClientAliceSendKeys(pk(skey_A_I_3),pk(skey_A_E_3)) at {8} in copy a

out(ch_c2s, (~M,~M_1)) with ~M = pk(skey_A_I_3), ~M_1 = pk(skey_A_E_3) at {9} in copy a

in(ch_s2c, (a_1,a_2)) at {10} in copy a

event evClientAliceReceiveKeys(a_1,a_2) at {11} in copy a

event evClientAliceCalcShareSecret(concat3(sca(skey_A_I_3,a_2),sca(skey_A_E_3,a_1),sca(skey_A_E_3,a_2))) at {18} in copy a

insert table1_client_alice(skey_A_I_3,skey_A_E_3,pk(skey_A_I_3),pk(skey_A_E_3),a_1,a_2,concat3(sca(skey_A_I_3,a_2),sca(skey_A_E_3,a_1),sca(skey_A_E_3,a_2))) at {19} in copy a

get table1_client_alice(skey_A_I_3,skey_A_E_3,pk(skey_A_I_3),pk(skey_A_E_3),a_1,a_2,concat3(sca(skey_A_I_3,a_2),sca(skey_A_E_3,a_1),sca(skey_A_E_3,a_2))) at {83} in copy a_3

event evClientAliceSendRatchetKey(pk(rk(skey_A_I_3))) at {61} in copy a_3

out(ch_c2s, ~M_2) with ~M_2 = pk(rk(skey_A_I_3)) at {62} in copy a_3

event evClientAliceSendCipertext(senccbc(plain_text_A,fist256bit(HKDF(SALT,HMAC_SHA256(next256bit(HKDF(SALT,concat3(sca(skey_A_I_3,a_2),sca(skey_A_E_3,a_1),sca(skey_A_E_3,a_2)),INFO,64)),PADDING_1),INFO,80)),last128bit(HKDF(SALT,HMAC_SHA256(next256bit(HKDF(SALT,concat3(sca(skey_A_I_3,a_2),sca(skey_A_E_3,a_1),sca(skey_A_E_3,a_2)),INFO,64)),PADDING_1),INFO,80)))) at {63} in copy a_3

out(ch_c2s, ~M_3) with ~M_3 = senccbc(plain_text_A,fist256bit(HKDF(SALT,HMAC_SHA256(next256bit(HKDF(SALT,concat3(sca(skey_A_I_3,a_2),sca(skey_A_E_3,a_1),sca(skey_A_E_3,a_2)),INFO,64)),PADDING_1),INFO,80)),last128bit(HKDF(SALT,HMAC_SHA256(next256bit(HKDF(SALT,concat3(sca(skey_A_I_3,a_2),sca(skey_A_E_3,a_1),sca(skey_A_E_3,a_2)),INFO,64)),PADDING_1),INFO,80))) at {64} in copy a_3

in(ch_s2c, a_4) at {65} in copy a_3

event evClientAliceReceiveRatchetKey(a_4) at {66} in copy a_3 (goal)

The event evClientAliceReceiveRatchetKey(a_4) is executed at {66} in copy a_3.
A trace has been found.
RESULT event(evClientAliceReceiveRatchetKey(ratchetKey)) ==> event(evClientBobSendRatchetKey(ratchetKey)) is false.
-- Query event(evClientBobReceiveRatchetKey(ratchetKey)) ==> event(evClientAliceSendRatchetKey(ratchetKey)) in process 1.
Translating the process into Horn clauses...
Completing...
200 rules inserted. Base: 187 rules (66 with conclusion selected). Queue: 32 rules.
Starting query event(evClientBobReceiveRatchetKey(ratchetKey)) ==> event(evClientAliceSendRatchetKey(ratchetKey))
goal reachable: attacker(ratchetKey) -> event(evClientBobReceiveRatchetKey(ratchetKey))

Derivation:
Abbreviations:
skey_B_E_2 = skey_B_E[!1 = @sid]

1. The attacker has some term pk_A_E_8.
attacker(pk_A_E_8).

2. The attacker has some term pk_A_I_8.
attacker(pk_A_I_8).

3. By 2, the attacker may know pk_A_I_8.
By 1, the attacker may know pk_A_E_8.
Using the function 2-tuple the attacker may obtain (pk_A_I_8,pk_A_E_8).
attacker((pk_A_I_8,pk_A_E_8)).

4. The message (pk_A_I_8,pk_A_E_8) that the attacker may have by 3 may be received at input {33}.
So the entry table1_client_bob(skey_B_I[],skey_B_E_2,pk(skey_B_I[]),pk(skey_B_E_2),pk_A_I_8,pk_A_E_8,concat3(sca(skey_B_I[],pk_A_E_8),sca(skey_B_E_2,pk_A_I_8),sca(skey_B_E_2,pk_A_E_8))) may be inserted in a table at insert {46}.
table(table1_client_bob(skey_B_I[],skey_B_E_2,pk(skey_B_I[]),pk(skey_B_E_2),pk_A_I_8,pk_A_E_8,concat3(sca(skey_B_I[],pk_A_E_8),sca(skey_B_E_2,pk_A_I_8),sca(skey_B_E_2,pk_A_E_8)))).

5. We assume as hypothesis that
attacker(ratchetKey).

6. The entry table1_client_bob(skey_B_I[],skey_B_E_2,pk(skey_B_I[]),pk(skey_B_E_2),pk_A_I_8,pk_A_E_8,concat3(sca(skey_B_I[],pk_A_E_8),sca(skey_B_E_2,pk_A_I_8),sca(skey_B_E_2,pk_A_E_8))) that may be in a table by 4 may be read at get {140}.
The message ratchetKey that the attacker may have by 5 may be received at input {112}.
So event evClientBobReceiveRatchetKey(ratchetKey) may be executed at {113}.
event(evClientBobReceiveRatchetKey(ratchetKey)).

7. By 6, event(evClientBobReceiveRatchetKey(ratchetKey)).
The goal is reached, represented in the following fact:
event(evClientBobReceiveRatchetKey(ratchetKey)).


A more detailed output of the traces is available with
  set traceDisplay = long.

new skey_A_I: skey creating skey_A_I_3 at {1}

new skey_B_I: skey creating skey_B_I_3 at {2}

new skey_B_E: skey creating skey_B_E_3 at {32} in copy a

in(ch_s2c, (a_1,a_2)) at {33} in copy a

event evClientBobReceiveKeys(a_1,a_2) at {34} in copy a

event evClientBobSendKeys(pk(skey_B_I_3),pk(skey_B_E_3)) at {37} in copy a

out(ch_c2s, (~M,~M_1)) with ~M = pk(skey_B_I_3), ~M_1 = pk(skey_B_E_3) at {38} in copy a

event evClientBobCalcShareSecret(concat3(sca(skey_B_I_3,a_2),sca(skey_B_E_3,a_1),sca(skey_B_E_3,a_2))) at {45} in copy a

insert table1_client_bob(skey_B_I_3,skey_B_E_3,pk(skey_B_I_3),pk(skey_B_E_3),a_1,a_2,concat3(sca(skey_B_I_3,a_2),sca(skey_B_E_3,a_1),sca(skey_B_E_3,a_2))) at {46} in copy a

get table1_client_bob(skey_B_I_3,skey_B_E_3,pk(skey_B_I_3),pk(skey_B_E_3),a_1,a_2,concat3(sca(skey_B_I_3,a_2),sca(skey_B_E_3,a_1),sca(skey_B_E_3,a_2))) at {140} in copy a_3

in(ch_s2c, a_4) at {112} in copy a_3

event evClientBobReceiveRatchetKey(a_4) at {113} in copy a_3 (goal)

The event evClientBobReceiveRatchetKey(a_4) is executed at {113} in copy a_3.
A trace has been found.
RESULT event(evClientBobReceiveRatchetKey(ratchetKey)) ==> event(evClientAliceSendRatchetKey(ratchetKey)) is false.
-- Query event(evClientAliceCalcShareSecret(SharedSecret)) ==> event(evClientBobCalcShareSecret(SharedSecret)) in process 1.
Translating the process into Horn clauses...
Completing...
200 rules inserted. Base: 188 rules (73 with conclusion selected). Queue: 11 rules.
400 rules inserted. Base: 348 rules (73 with conclusion selected). Queue: 9 rules.
Starting query event(evClientAliceCalcShareSecret(SharedSecret)) ==> event(evClientBobCalcShareSecret(SharedSecret))
goal reachable: attacker(y) && attacker(pk_B_E_8) -> event(evClientAliceCalcShareSecret(concat3(sca(skey_A_I[],pk_B_E_8),sca(y,sca(skey_A_E_2,P)),sca(skey_A_E_2,pk_B_E_8))))
Abbreviations:
skey_A_E_2 = skey_A_E[!1 = @sid]

Derivation:
Abbreviations:
skey_A_E_2 = skey_A_E[!1 = @sid]

1. We assume as hypothesis that
attacker(pk_B_E_8).

2. Using the function P the attacker may obtain P.
attacker(P).

3. We assume as hypothesis that
attacker(y).

4. By 3, the attacker may know y.
By 2, the attacker may know P.
Using the function sca the attacker may obtain sca(y,P).
attacker(sca(y,P)).

5. By 4, the attacker may know sca(y,P).
By 1, the attacker may know pk_B_E_8.
Using the function 2-tuple the attacker may obtain (sca(y,P),pk_B_E_8).
attacker((sca(y,P),pk_B_E_8)).

6. The message (sca(y,P),pk_B_E_8) that the attacker may have by 5 may be received at input {10}.
So event evClientAliceCalcShareSecret(concat3(sca(skey_A_I[],pk_B_E_8),sca(y,sca(skey_A_E_2,P)),sca(skey_A_E_2,pk_B_E_8))) may be executed at {18}.
event(evClientAliceCalcShareSecret(concat3(sca(skey_A_I[],pk_B_E_8),sca(y,sca(skey_A_E_2,P)),sca(skey_A_E_2,pk_B_E_8)))).

7. By 6, event(evClientAliceCalcShareSecret(concat3(sca(skey_A_I[],pk_B_E_8),sca(y,sca(skey_A_E_2,P)),sca(skey_A_E_2,pk_B_E_8)))).
The goal is reached, represented in the following fact:
event(evClientAliceCalcShareSecret(concat3(sca(skey_A_I[],pk_B_E_8),sca(y,sca(skey_A_E_2,P)),sca(skey_A_E_2,pk_B_E_8)))).


A more detailed output of the traces is available with
  set traceDisplay = long.

new skey_A_I: skey creating skey_A_I_3 at {1}

new skey_B_I: skey creating skey_B_I_3 at {2}

new skey_A_E: skey creating skey_A_E_3 at {5} in copy a

event evClientAliceSendKeys(pk(skey_A_I_3),pk(skey_A_E_3)) at {8} in copy a

out(ch_c2s, (~M,~M_1)) with ~M = pk(skey_A_I_3), ~M_1 = pk(skey_A_E_3) at {9} in copy a

in(ch_s2c, (sca(a_1,P),a_2)) at {10} in copy a

event evClientAliceReceiveKeys(sca(a_1,P),a_2) at {11} in copy a

event evClientAliceCalcShareSecret(concat3(sca(skey_A_I_3,a_2),sca(skey_A_E_3,sca(a_1,P)),sca(skey_A_E_3,a_2))) at {18} in copy a (goal)

The event evClientAliceCalcShareSecret(concat3(sca(skey_A_I_3,a_2),sca(a_1,sca(skey_A_E_3,P)),sca(skey_A_E_3,a_2))) is executed at {18} in copy a.
A trace has been found.
RESULT event(evClientAliceCalcShareSecret(SharedSecret)) ==> event(evClientBobCalcShareSecret(SharedSecret)) is false.
-- Query event(evClientBobCalcShareSecret(SharedSecret)) ==> event(evClientAliceCalcShareSecret(SharedSecret)) in process 1.
Translating the process into Horn clauses...
Completing...
200 rules inserted. Base: 188 rules (80 with conclusion selected). Queue: 11 rules.
400 rules inserted. Base: 351 rules (80 with conclusion selected). Queue: 13 rules.
Starting query event(evClientBobCalcShareSecret(SharedSecret)) ==> event(evClientAliceCalcShareSecret(SharedSecret))
goal reachable: attacker(y) && attacker(pk_A_E_8) -> event(evClientBobCalcShareSecret(concat3(sca(skey_B_I[],pk_A_E_8),sca(y,sca(skey_B_E_2,P)),sca(skey_B_E_2,pk_A_E_8))))
Abbreviations:
skey_B_E_2 = skey_B_E[!1 = @sid]

Derivation:
Abbreviations:
skey_B_E_2 = skey_B_E[!1 = @sid]

1. We assume as hypothesis that
attacker(pk_A_E_8).

2. Using the function P the attacker may obtain P.
attacker(P).

3. We assume as hypothesis that
attacker(y).

4. By 3, the attacker may know y.
By 2, the attacker may know P.
Using the function sca the attacker may obtain sca(y,P).
attacker(sca(y,P)).

5. By 4, the attacker may know sca(y,P).
By 1, the attacker may know pk_A_E_8.
Using the function 2-tuple the attacker may obtain (sca(y,P),pk_A_E_8).
attacker((sca(y,P),pk_A_E_8)).

6. The message (sca(y,P),pk_A_E_8) that the attacker may have by 5 may be received at input {33}.
So event evClientBobCalcShareSecret(concat3(sca(skey_B_I[],pk_A_E_8),sca(y,sca(skey_B_E_2,P)),sca(skey_B_E_2,pk_A_E_8))) may be executed at {45}.
event(evClientBobCalcShareSecret(concat3(sca(skey_B_I[],pk_A_E_8),sca(y,sca(skey_B_E_2,P)),sca(skey_B_E_2,pk_A_E_8)))).

7. By 6, event(evClientBobCalcShareSecret(concat3(sca(skey_B_I[],pk_A_E_8),sca(y,sca(skey_B_E_2,P)),sca(skey_B_E_2,pk_A_E_8)))).
The goal is reached, represented in the following fact:
event(evClientBobCalcShareSecret(concat3(sca(skey_B_I[],pk_A_E_8),sca(y,sca(skey_B_E_2,P)),sca(skey_B_E_2,pk_A_E_8)))).


A more detailed output of the traces is available with
  set traceDisplay = long.

new skey_A_I: skey creating skey_A_I_3 at {1}

new skey_B_I: skey creating skey_B_I_3 at {2}

new skey_B_E: skey creating skey_B_E_3 at {32} in copy a

in(ch_s2c, (sca(a_1,P),a_2)) at {33} in copy a

event evClientBobReceiveKeys(sca(a_1,P),a_2) at {34} in copy a

event evClientBobSendKeys(pk(skey_B_I_3),pk(skey_B_E_3)) at {37} in copy a

out(ch_c2s, (~M,~M_1)) with ~M = pk(skey_B_I_3), ~M_1 = pk(skey_B_E_3) at {38} in copy a

event evClientBobCalcShareSecret(concat3(sca(skey_B_I_3,a_2),sca(skey_B_E_3,sca(a_1,P)),sca(skey_B_E_3,a_2))) at {45} in copy a (goal)

The event evClientBobCalcShareSecret(concat3(sca(skey_B_I_3,a_2),sca(a_1,sca(skey_B_E_3,P)),sca(skey_B_E_3,a_2))) is executed at {45} in copy a.
A trace has been found.
RESULT event(evClientBobCalcShareSecret(SharedSecret)) ==> event(evClientAliceCalcShareSecret(SharedSecret)) is false.
-- Query event(evClientAliceReceiveCipertext(ciper_text)) ==> event(evClientBobSendCipertext(ciper_text)) in process 1.
Translating the process into Horn clauses...
Completing...
200 rules inserted. Base: 187 rules (66 with conclusion selected). Queue: 32 rules.
Starting query event(evClientAliceReceiveCipertext(ciper_text)) ==> event(evClientBobSendCipertext(ciper_text))
goal reachable: attacker(ciper_text) -> event(evClientAliceReceiveCipertext(ciper_text))

Derivation:
Abbreviations:
skey_A_E_2 = skey_A_E[!1 = @sid]

1. The attacker has some term pk_B_E_8.
attacker(pk_B_E_8).

2. The attacker has some term pk_B_I_8.
attacker(pk_B_I_8).

3. By 2, the attacker may know pk_B_I_8.
By 1, the attacker may know pk_B_E_8.
Using the function 2-tuple the attacker may obtain (pk_B_I_8,pk_B_E_8).
attacker((pk_B_I_8,pk_B_E_8)).

4. The message (pk_B_I_8,pk_B_E_8) that the attacker may have by 3 may be received at input {10}.
So the entry table1_client_alice(skey_A_I[],skey_A_E_2,pk(skey_A_I[]),pk(skey_A_E_2),pk_B_I_8,pk_B_E_8,concat3(sca(skey_A_I[],pk_B_E_8),sca(skey_A_E_2,pk_B_I_8),sca(skey_A_E_2,pk_B_E_8))) may be inserted in a table at insert {19}.
table(table1_client_alice(skey_A_I[],skey_A_E_2,pk(skey_A_I[]),pk(skey_A_E_2),pk_B_I_8,pk_B_E_8,concat3(sca(skey_A_I[],pk_B_E_8),sca(skey_A_E_2,pk_B_I_8),sca(skey_A_E_2,pk_B_E_8)))).

5. The attacker has some term pk_ratchetKey_B_3.
attacker(pk_ratchetKey_B_3).

6. We assume as hypothesis that
attacker(ciper_text).

7. The entry table1_client_alice(skey_A_I[],skey_A_E_2,pk(skey_A_I[]),pk(skey_A_E_2),pk_B_I_8,pk_B_E_8,concat3(sca(skey_A_I[],pk_B_E_8),sca(skey_A_E_2,pk_B_I_8),sca(skey_A_E_2,pk_B_E_8))) that may be in a table by 4 may be read at get {83}.
The message pk_ratchetKey_B_3 that the attacker may have by 5 may be received at input {65}.
The message ciper_text that the attacker may have by 6 may be received at input {67}.
So event evClientAliceReceiveCipertext(ciper_text) may be executed at {68}.
event(evClientAliceReceiveCipertext(ciper_text)).

8. By 7, event(evClientAliceReceiveCipertext(ciper_text)).
The goal is reached, represented in the following fact:
event(evClientAliceReceiveCipertext(ciper_text)).


A more detailed output of the traces is available with
  set traceDisplay = long.

new skey_A_I: skey creating skey_A_I_3 at {1}

new skey_B_I: skey creating skey_B_I_3 at {2}

new skey_A_E: skey creating skey_A_E_3 at {5} in copy a

event evClientAliceSendKeys(pk(skey_A_I_3),pk(skey_A_E_3)) at {8} in copy a

out(ch_c2s, (~M,~M_1)) with ~M = pk(skey_A_I_3), ~M_1 = pk(skey_A_E_3) at {9} in copy a

in(ch_s2c, (a_1,a_2)) at {10} in copy a

event evClientAliceReceiveKeys(a_1,a_2) at {11} in copy a

event evClientAliceCalcShareSecret(concat3(sca(skey_A_I_3,a_2),sca(skey_A_E_3,a_1),sca(skey_A_E_3,a_2))) at {18} in copy a

insert table1_client_alice(skey_A_I_3,skey_A_E_3,pk(skey_A_I_3),pk(skey_A_E_3),a_1,a_2,concat3(sca(skey_A_I_3,a_2),sca(skey_A_E_3,a_1),sca(skey_A_E_3,a_2))) at {19} in copy a

get table1_client_alice(skey_A_I_3,skey_A_E_3,pk(skey_A_I_3),pk(skey_A_E_3),a_1,a_2,concat3(sca(skey_A_I_3,a_2),sca(skey_A_E_3,a_1),sca(skey_A_E_3,a_2))) at {83} in copy a_3

event evClientAliceSendRatchetKey(pk(rk(skey_A_I_3))) at {61} in copy a_3

out(ch_c2s, ~M_2) with ~M_2 = pk(rk(skey_A_I_3)) at {62} in copy a_3

event evClientAliceSendCipertext(senccbc(plain_text_A,fist256bit(HKDF(SALT,HMAC_SHA256(next256bit(HKDF(SALT,concat3(sca(skey_A_I_3,a_2),sca(skey_A_E_3,a_1),sca(skey_A_E_3,a_2)),INFO,64)),PADDING_1),INFO,80)),last128bit(HKDF(SALT,HMAC_SHA256(next256bit(HKDF(SALT,concat3(sca(skey_A_I_3,a_2),sca(skey_A_E_3,a_1),sca(skey_A_E_3,a_2)),INFO,64)),PADDING_1),INFO,80)))) at {63} in copy a_3

out(ch_c2s, ~M_3) with ~M_3 = senccbc(plain_text_A,fist256bit(HKDF(SALT,HMAC_SHA256(next256bit(HKDF(SALT,concat3(sca(skey_A_I_3,a_2),sca(skey_A_E_3,a_1),sca(skey_A_E_3,a_2)),INFO,64)),PADDING_1),INFO,80)),last128bit(HKDF(SALT,HMAC_SHA256(next256bit(HKDF(SALT,concat3(sca(skey_A_I_3,a_2),sca(skey_A_E_3,a_1),sca(skey_A_E_3,a_2)),INFO,64)),PADDING_1),INFO,80))) at {64} in copy a_3

in(ch_s2c, a_4) at {65} in copy a_3

event evClientAliceReceiveRatchetKey(a_4) at {66} in copy a_3

in(ch_s2c, a_5) at {67} in copy a_3

event evClientAliceReceiveCipertext(a_5) at {68} in copy a_3 (goal)

The event evClientAliceReceiveCipertext(a_5) is executed at {68} in copy a_3.
A trace has been found.
RESULT event(evClientAliceReceiveCipertext(ciper_text)) ==> event(evClientBobSendCipertext(ciper_text)) is false.
-- Query event(evClientBobReceiveCipertext(ciper_text)) ==> event(evClientAliceSendCipertext(ciper_text)) in process 1.
Translating the process into Horn clauses...
Completing...
200 rules inserted. Base: 187 rules (66 with conclusion selected). Queue: 32 rules.
Starting query event(evClientBobReceiveCipertext(ciper_text)) ==> event(evClientAliceSendCipertext(ciper_text))
goal reachable: attacker(ciper_text) -> event(evClientBobReceiveCipertext(ciper_text))

Derivation:
Abbreviations:
skey_B_E_2 = skey_B_E[!1 = @sid]

1. The attacker has some term pk_A_E_8.
attacker(pk_A_E_8).

2. The attacker has some term pk_A_I_8.
attacker(pk_A_I_8).

3. By 2, the attacker may know pk_A_I_8.
By 1, the attacker may know pk_A_E_8.
Using the function 2-tuple the attacker may obtain (pk_A_I_8,pk_A_E_8).
attacker((pk_A_I_8,pk_A_E_8)).

4. The message (pk_A_I_8,pk_A_E_8) that the attacker may have by 3 may be received at input {33}.
So the entry table1_client_bob(skey_B_I[],skey_B_E_2,pk(skey_B_I[]),pk(skey_B_E_2),pk_A_I_8,pk_A_E_8,concat3(sca(skey_B_I[],pk_A_E_8),sca(skey_B_E_2,pk_A_I_8),sca(skey_B_E_2,pk_A_E_8))) may be inserted in a table at insert {46}.
table(table1_client_bob(skey_B_I[],skey_B_E_2,pk(skey_B_I[]),pk(skey_B_E_2),pk_A_I_8,pk_A_E_8,concat3(sca(skey_B_I[],pk_A_E_8),sca(skey_B_E_2,pk_A_I_8),sca(skey_B_E_2,pk_A_E_8)))).

5. The attacker has some term pk_ratchetKey_A_3.
attacker(pk_ratchetKey_A_3).

6. We assume as hypothesis that
attacker(ciper_text).

7. The entry table1_client_bob(skey_B_I[],skey_B_E_2,pk(skey_B_I[]),pk(skey_B_E_2),pk_A_I_8,pk_A_E_8,concat3(sca(skey_B_I[],pk_A_E_8),sca(skey_B_E_2,pk_A_I_8),sca(skey_B_E_2,pk_A_E_8))) that may be in a table by 4 may be read at get {140}.
The message pk_ratchetKey_A_3 that the attacker may have by 5 may be received at input {112}.
The message ciper_text that the attacker may have by 6 may be received at input {114}.
So event evClientBobReceiveCipertext(ciper_text) may be executed at {115}.
event(evClientBobReceiveCipertext(ciper_text)).

8. By 7, event(evClientBobReceiveCipertext(ciper_text)).
The goal is reached, represented in the following fact:
event(evClientBobReceiveCipertext(ciper_text)).


A more detailed output of the traces is available with
  set traceDisplay = long.

new skey_A_I: skey creating skey_A_I_3 at {1}

new skey_B_I: skey creating skey_B_I_3 at {2}

new skey_B_E: skey creating skey_B_E_3 at {32} in copy a

in(ch_s2c, (a_1,a_2)) at {33} in copy a

event evClientBobReceiveKeys(a_1,a_2) at {34} in copy a

event evClientBobSendKeys(pk(skey_B_I_3),pk(skey_B_E_3)) at {37} in copy a

out(ch_c2s, (~M,~M_1)) with ~M = pk(skey_B_I_3), ~M_1 = pk(skey_B_E_3) at {38} in copy a

event evClientBobCalcShareSecret(concat3(sca(skey_B_I_3,a_2),sca(skey_B_E_3,a_1),sca(skey_B_E_3,a_2))) at {45} in copy a

insert table1_client_bob(skey_B_I_3,skey_B_E_3,pk(skey_B_I_3),pk(skey_B_E_3),a_1,a_2,concat3(sca(skey_B_I_3,a_2),sca(skey_B_E_3,a_1),sca(skey_B_E_3,a_2))) at {46} in copy a

get table1_client_bob(skey_B_I_3,skey_B_E_3,pk(skey_B_I_3),pk(skey_B_E_3),a_1,a_2,concat3(sca(skey_B_I_3,a_2),sca(skey_B_E_3,a_1),sca(skey_B_E_3,a_2))) at {140} in copy a_3

in(ch_s2c, a_4) at {112} in copy a_3

event evClientBobReceiveRatchetKey(a_4) at {113} in copy a_3

in(ch_s2c, a_5) at {114} in copy a_3

event evClientBobReceiveCipertext(a_5) at {115} in copy a_3 (goal)

The event evClientBobReceiveCipertext(a_5) is executed at {115} in copy a_3.
A trace has been found.
RESULT event(evClientBobReceiveCipertext(ciper_text)) ==> event(evClientAliceSendCipertext(ciper_text)) is false.
-- Query event(evClientAliceDecryptPlaintext(plain_text)) ==> event(evClientBobSendCipertext(ciper_text)) in process 1.
Translating the process into Horn clauses...
Completing...
200 rules inserted. Base: 186 rules (65 with conclusion selected). Queue: 20 rules.
400 rules inserted. Base: 353 rules (65 with conclusion selected). Queue: 19 rules.
Starting query event(evClientAliceDecryptPlaintext(plain_text)) ==> event(evClientBobSendCipertext(ciper_text))
RESULT event(evClientAliceDecryptPlaintext(plain_text)) ==> event(evClientBobSendCipertext(ciper_text)) is true.
-- Query event(evClientBobDecryptPlaintext(plain_text)) ==> event(evClientAliceSendCipertext(ciper_text)) in process 1.
Translating the process into Horn clauses...
Completing...
200 rules inserted. Base: 187 rules (65 with conclusion selected). Queue: 26 rules.
400 rules inserted. Base: 356 rules (65 with conclusion selected). Queue: 21 rules.
Starting query event(evClientBobDecryptPlaintext(plain_text)) ==> event(evClientAliceSendCipertext(ciper_text))
RESULT event(evClientBobDecryptPlaintext(plain_text)) ==> event(evClientAliceSendCipertext(ciper_text)) is true.
-- Query not attacker(plain_text_A[]) in process 1.
Translating the process into Horn clauses...
Completing...
200 rules inserted. Base: 188 rules (65 with conclusion selected). Queue: 32 rules.
Starting query not attacker(plain_text_A[])
RESULT not attacker(plain_text_A[]) is true.
-- Query not attacker(plain_text_B[]) in process 1.
Translating the process into Horn clauses...
Completing...
200 rules inserted. Base: 188 rules (65 with conclusion selected). Queue: 32 rules.
Starting query not attacker(plain_text_B[])
RESULT not attacker(plain_text_B[]) is true.
-- Query not attacker(cipher_text_A[]) in process 1.
Translating the process into Horn clauses...
Completing...
200 rules inserted. Base: 188 rules (65 with conclusion selected). Queue: 32 rules.
Starting query not attacker(cipher_text_A[])
RESULT not attacker(cipher_text_A[]) is true.
-- Query not attacker(cipher_text_B[]) in process 1.
Translating the process into Horn clauses...
Completing...
200 rules inserted. Base: 188 rules (65 with conclusion selected). Queue: 32 rules.
Starting query not attacker(cipher_text_B[])
RESULT not attacker(cipher_text_B[]) is true.

--------------------------------------------------------------
Verification summary:

Query event(evClientBobReceiveKeys(pk_I,pk_E)) ==> event(evClientAliceSendKeys(pk_I,pk_E)) is false.

Query event(evClientAliceReceiveKeys(pk_I,pk_E)) ==> event(evClientBobSendKeys(pk_I,pk_E)) is false.

Query event(evClientAliceCalcShareSecret(SharedSecret)) ==> event(evClientBobSendKeys(pk_I,pk_E)) is false.

Query event(evClientBobCalcShareSecret(SharedSecret)) ==> event(evClientAliceSendKeys(pk_I,pk_E)) is false.

Query event(evClientAliceReceiveRatchetKey(ratchetKey)) ==> event(evClientBobSendRatchetKey(ratchetKey)) is false.

Query event(evClientBobReceiveRatchetKey(ratchetKey)) ==> event(evClientAliceSendRatchetKey(ratchetKey)) is false.

Query event(evClientAliceCalcShareSecret(SharedSecret)) ==> event(evClientBobCalcShareSecret(SharedSecret)) is false.

Query event(evClientBobCalcShareSecret(SharedSecret)) ==> event(evClientAliceCalcShareSecret(SharedSecret)) is false.

Query event(evClientAliceReceiveCipertext(ciper_text)) ==> event(evClientBobSendCipertext(ciper_text)) is false.

Query event(evClientBobReceiveCipertext(ciper_text)) ==> event(evClientAliceSendCipertext(ciper_text)) is false.

Query event(evClientAliceDecryptPlaintext(plain_text)) ==> event(evClientBobSendCipertext(ciper_text)) is true.

Query event(evClientBobDecryptPlaintext(plain_text)) ==> event(evClientAliceSendCipertext(ciper_text)) is true.

Query not attacker(plain_text_A[]) is true.

Query not attacker(plain_text_B[]) is true.

Query not attacker(cipher_text_A[]) is true.

Query not attacker(cipher_text_B[]) is true.

--------------------------------------------------------------

