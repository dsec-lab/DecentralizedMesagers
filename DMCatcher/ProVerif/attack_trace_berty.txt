File "./berty-handshake-encryption-protocol.pv", line 184, characters 13-14:
Warning: identifier OK rebound.
File "./berty-handshake-encryption-protocol.pv", line 235, characters 46-52:
Warning: identifier counter rebound.
File "./berty-handshake-encryption-protocol.pv", line 241, characters 6-23:
Warning: identifier plainTextRequester rebound.
File "./berty-handshake-encryption-protocol.pv", line 259, characters 6-23:
Warning: identifier plainTextResponder rebound.
Linear part:
sca(x,sca(y,P)) = sca(y,sca(x,P))
Completing equations...
Completed equations:
sca(x,sca(y,P)) = sca(y,sca(x,P))
Convergent part: No equation.
Process 0 (that is, the initial process):
{1}new skey_A_I: privateKey;
{2}new skey_B_I: privateKey;
(
    {3}!
    {4}let skey_A_I_1: privateKey = skey_A_I in
    {5}new skey_A_E: privateKey;
    {6}let pk_A_I: publicKey = pk(skey_A_I_1) in
    {7}let pk_A_E: publicKey = pk(skey_A_E) in
    {8}event evRequesterHelloSendKey(pk_A_E);
    {9}out(ch_c2s, pk_A_E);
    {10}insert step1_table_requester(skey_A_I_1,skey_A_E)
) | (
    {11}!
    {12}in(ch_c2s, pk_A_E_1: publicKey);
    {13}out(ch_s2c, pk_A_E_1)
) | (
    {14}!
    {15}in(ch_s2c, pk_A_E_2: publicKey);
    {16}event evResponderHelloReceiveKey(pk_A_E_2);
    {17}insert step1_table_responder(pk_A_E_2)
) | (
    {18}!
    {19}let skey_B_I_1: privateKey = skey_B_I in
    {30}get step1_table_responder(pk_A_E_3: publicKey) in
    {20}new skey_B_E: privateKey;
    {21}let pk_B_I: publicKey = pk(skey_B_I_1) in
    {22}let pk_B_E: publicKey = pk(skey_B_E) in
    {23}event evResponderHelloSendKey(pk_B_E);
    {24}out(ch_c2s, (pk_B_I,pk_B_E));
    {25}let sk: privateKey = skey_B_E in
    {26}let ecdhkey_ab_Responder: G = sca(sk,pk_A_E_3) in
    {27}let ecdhkey_aB_Responder: G = sca(skey_B_I_1,pk_A_E_3) in
    {28}event evResponderCalcShareSecret(ecdhkey_ab_Responder,ecdhkey_aB_Responder);
    {29}insert step2_table_responder(ecdhkey_ab_Responder,ecdhkey_aB_Responder,skey_B_I_1)
) | (
    {31}!
    {32}in(ch_c2s, (pk_B_I_1: publicKey,pk_B_E_1: publicKey));
    {33}out(ch_s2c, (pk_B_I_1,pk_B_E_1))
) | (
    {34}!
    {43}get step1_table_requester(skey_A_I_2: privateKey,skey_A_E_1: privateKey) in
    {35}in(ch_s2c, (pk_B_I_2: publicKey,pk_B_E_2: publicKey));
    {36}event evResponderHelloReceiveKey(pk_B_I_2);
    {37}event evResponderHelloReceiveKey(pk_B_E_2);
    {38}let ecdhkey_ab_Requester: G = sca(skey_A_E_1,pk_B_E_2) in
    {39}let ecdhkey_aB_Requester: G = sca(skey_A_E_1,pk_B_I_2) in
    {40}event evRequesterCalcShareSecret(ecdhkey_ab_Requester,ecdhkey_aB_Requester);
    {41}let pk_A_I_1: publicKey = pk(skey_A_I_2) in
    {42}insert step2_table_requester(ecdhkey_ab_Requester,ecdhkey_aB_Requester,pk_A_I_1,skey_A_I_2,pk_B_I_2)
) | (
    {44}!
    {57}get step2_table_requester(ecdhkey_ab_Requester_1: sharedKey,ecdhkey_aB_Requester_1: sharedKey,pk_A_I_2: publicKey,skey_A_I_3: privateKey,pk_B_I_3: publicKey) in
    {45}let boxKeyRequester: boxKey = boxSeal(ecdhkey_ab_Requester_1,ecdhkey_aB_Requester_1,pk_A_I_2,sign(skey_A_I_3,ecdhkey_ab_Requester_1)) in
    {46}event evRequesterSealPublicKey(pk_A_I_2);
    {47}out(ch_c2c, boxKeyRequester);
    {48}event evRequesterSendboxKey(boxKeyRequester);
    {49}let ecdhkey_AB_Requester: G = sca(skey_A_I_3,pk_B_I_3) in
    {50}event evRequesterAuthenticateCalcSharedKey(ecdhkey_AB_Requester);
    {51}insert step3_table_requester(ecdhkey_AB_Requester);
    {52}in(ch_c2c, boxKeyResponder: boxKey);
    {53}let signKeyResponder: bitstring = unboxSealRequester(ecdhkey_ab_Requester_1,ecdhkey_AB_Requester,boxKeyResponder) in
    {54}event evRequesterReceiveboxKey(boxKeyResponder);
    {55}let ecdhkey_ab_Responder_1: bitstring = unsign(signKeyResponder,pk_B_I_3) in
    {56}out(ch_c2c, OK)
) | (
    {58}!
    {70}get step2_table_responder(ecdhkey_ab_Responder_2: sharedKey,ecdhkey_aB_Responder_1: sharedKey,skey_B_I_2: privateKey) in
    {59}in(ch_c2c, boxKeyRequester_1: boxKey);
    {60}let pk_A_I_3: publicKey = unboxSeal(ecdhkey_ab_Responder_2,ecdhkey_aB_Responder_1,boxKeyRequester_1) in
    {61}event evResponderCalcPublicKey(pk_A_I_3);
    {62}let ecdhkey_AB_Responder: G = sca(skey_B_I_2,pk_A_I_3) in
    {63}event evResponderAuthenticateCalcSharedKey(ecdhkey_AB_Responder);
    {64}insert step3_table_responder(ecdhkey_ab_Responder_2,ecdhkey_AB_Responder,skey_B_I_2);
    {65}insert step6_table_responder(ecdhkey_AB_Responder);
    {66}let boxKeyResponder_1: boxKey = boxSealResponder(ecdhkey_ab_Responder_2,ecdhkey_AB_Responder,sign(skey_B_I_2,ecdhkey_ab_Responder_2)) in
    {67}out(ch_c2c, boxKeyResponder_1);
    {68}event evResponderSendboxKey(boxKeyResponder_1);
    {69}in(ch_c2c, OK_1: bitstring)
) | (
    {71}!
    {80}get step3_table_requester(ecdhkey_AB_Requester_1: sharedKey) in
    {72}let Constant: nonce = uint64AsNonce(counter) in
    {73}let init_CK_Requester: chainKey = ecdhkey_AB_Requester_1 in
    {74}let OKM: bitstring = HKDF(init_CK_Requester,Constant) in
    {75}let (nextCK_Requester: chainKey,MK: msgKey) = (fist256bit(OKM),next256bit(OKM)) in
    {76}let cipherTextRequester: bitstring = secretBoxSeal(plainTextRequester,Constant,MK) in
    {77}out(ch_c2c, (cipherTextRequester,counter));
    {78}event evRequesterSendcipherText(cipherTextRequester);
    {79}insert step6_table_requester(nextCK_Requester)
) | (
    {81}!
    {96}get step6_table_responder(ecdhkey_AB_Responder_1: sharedKey) in
    {82}in(ch_c2c, (cipherTextRequester_1: bitstring,counter_1: number));
    {83}event evResponderReceiveCipherText(cipherTextRequester_1);
    {84}let Constant_1: nonce = uint64AsNonce(counter_1) in
    {85}let init_CK_Responder: chainKey = ecdhkey_AB_Responder_1 in
    {86}let OKM_1: bitstring = HKDF(init_CK_Responder,Constant_1) in
    {87}let (next_CK_Responder: chainKey,MK_Responder: msgKey) = (fist256bit(OKM_1),next256bit(OKM_1)) in
    {88}let plainTextRequester_1: bitstring = secretBoxOpen(cipherTextRequester_1,Constant_1,MK_Responder) in
    {89}let nextCounter: number = updateCounter(counter_1) in
    {90}let nextConstant: nonce = uint64AsNonce(nextCounter) in
    {91}let OKM_2: bitstring = HKDF(next_CK_Responder,nextConstant) in
    {92}let (next_next_CK_Responder: chainKey,nextMK: msgKey) = (fist256bit(OKM_2),next256bit(OKM_2)) in
    {93}let cipherTextResponder: bitstring = secretBoxSeal(plainTextResponder,nextConstant,nextMK) in
    {94}out(ch_c2c, (cipherTextResponder,nextCounter));
    {95}event evResponderSendCipherText(cipherTextResponder)
) | (
    {97}!
    {104}get step6_table_requester(nextCK_Requester_1: chainKey) in
    {98}in(ch_c2c, (cipherTextResponder_1: bitstring,newCounter: number));
    {99}let Constant_2: nonce = uint64AsNonce(newCounter) in
    {100}let OKM_3: bitstring = HKDF(nextCK_Requester_1,Constant_2) in
    {101}let (next_next_CK_Requester: chainKey,nextMK_Requester: msgKey) = (fist256bit(OKM_3),next256bit(OKM_3)) in
    {102}let plainTextResponder_1: bitstring = secretBoxOpen(cipherTextResponder_1,Constant_2,nextMK_Requester) in
    {103}event evRequesterReceiveCipherText(plainTextResponder_1)
)

File "./berty-handshake-encryption-protocol.pv", line 272, characters 7-24:
Warning: identifier plainTextResponder rebound.
--  Process 1 (that is, process 0, with let moved downwards):
{1}new skey_A_I: privateKey;
{2}new skey_B_I: privateKey;
(
    {3}!
    {5}new skey_A_E: privateKey;
    {7}let pk_A_E: publicKey = pk(skey_A_E) in
    {8}event evRequesterHelloSendKey(pk_A_E);
    {9}out(ch_c2s, pk_A_E);
    {4}let skey_A_I_1: privateKey = skey_A_I in
    {10}insert step1_table_requester(skey_A_I_1,skey_A_E)
) | (
    {11}!
    {12}in(ch_c2s, pk_A_E_1: publicKey);
    {13}out(ch_s2c, pk_A_E_1)
) | (
    {14}!
    {15}in(ch_s2c, pk_A_E_2: publicKey);
    {16}event evResponderHelloReceiveKey(pk_A_E_2);
    {17}insert step1_table_responder(pk_A_E_2)
) | (
    {18}!
    {30}get step1_table_responder(pk_A_E_3: publicKey) in
    {20}new skey_B_E: privateKey;
    {22}let pk_B_E: publicKey = pk(skey_B_E) in
    {23}event evResponderHelloSendKey(pk_B_E);
    {19}let skey_B_I_1: privateKey = skey_B_I in
    {21}let pk_B_I: publicKey = pk(skey_B_I_1) in
    {24}out(ch_c2s, (pk_B_I,pk_B_E));
    {27}let ecdhkey_aB_Responder: G = sca(skey_B_I_1,pk_A_E_3) in
    {25}let sk: privateKey = skey_B_E in
    {26}let ecdhkey_ab_Responder: G = sca(sk,pk_A_E_3) in
    {28}event evResponderCalcShareSecret(ecdhkey_ab_Responder,ecdhkey_aB_Responder);
    {29}insert step2_table_responder(ecdhkey_ab_Responder,ecdhkey_aB_Responder,skey_B_I_1)
) | (
    {31}!
    {32}in(ch_c2s, (pk_B_I_1: publicKey,pk_B_E_1: publicKey));
    {33}out(ch_s2c, (pk_B_I_1,pk_B_E_1))
) | (
    {34}!
    {43}get step1_table_requester(skey_A_I_2: privateKey,skey_A_E_1: privateKey) in
    {35}in(ch_s2c, (pk_B_I_2: publicKey,pk_B_E_2: publicKey));
    {36}event evResponderHelloReceiveKey(pk_B_I_2);
    {37}event evResponderHelloReceiveKey(pk_B_E_2);
    {39}let ecdhkey_aB_Requester: G = sca(skey_A_E_1,pk_B_I_2) in
    {38}let ecdhkey_ab_Requester: G = sca(skey_A_E_1,pk_B_E_2) in
    {40}event evRequesterCalcShareSecret(ecdhkey_ab_Requester,ecdhkey_aB_Requester);
    {41}let pk_A_I_1: publicKey = pk(skey_A_I_2) in
    {42}insert step2_table_requester(ecdhkey_ab_Requester,ecdhkey_aB_Requester,pk_A_I_1,skey_A_I_2,pk_B_I_2)
) | (
    {44}!
    {57}get step2_table_requester(ecdhkey_ab_Requester_1: sharedKey,ecdhkey_aB_Requester_1: sharedKey,pk_A_I_2: publicKey,skey_A_I_3: privateKey,pk_B_I_3: publicKey) in
    {46}event evRequesterSealPublicKey(pk_A_I_2);
    {45}let boxKeyRequester: boxKey = boxSeal(ecdhkey_ab_Requester_1,ecdhkey_aB_Requester_1,pk_A_I_2,sign(skey_A_I_3,ecdhkey_ab_Requester_1)) in
    {47}out(ch_c2c, boxKeyRequester);
    {48}event evRequesterSendboxKey(boxKeyRequester);
    {49}let ecdhkey_AB_Requester: G = sca(skey_A_I_3,pk_B_I_3) in
    {50}event evRequesterAuthenticateCalcSharedKey(ecdhkey_AB_Requester);
    {51}insert step3_table_requester(ecdhkey_AB_Requester);
    {52}in(ch_c2c, boxKeyResponder: boxKey);
    {54}event evRequesterReceiveboxKey(boxKeyResponder);
    {56}out(ch_c2c, OK)
) | (
    {58}!
    {70}get step2_table_responder(ecdhkey_ab_Responder_2: sharedKey,ecdhkey_aB_Responder_1: sharedKey,skey_B_I_2: privateKey) in
    {59}in(ch_c2c, boxKeyRequester_1: boxKey);
    {60}let pk_A_I_3: publicKey = unboxSeal(ecdhkey_ab_Responder_2,ecdhkey_aB_Responder_1,boxKeyRequester_1) in
    {61}event evResponderCalcPublicKey(pk_A_I_3);
    {62}let ecdhkey_AB_Responder: G = sca(skey_B_I_2,pk_A_I_3) in
    {63}event evResponderAuthenticateCalcSharedKey(ecdhkey_AB_Responder);
    {64}insert step3_table_responder(ecdhkey_ab_Responder_2,ecdhkey_AB_Responder,skey_B_I_2);
    {65}insert step6_table_responder(ecdhkey_AB_Responder);
    {66}let boxKeyResponder_1: boxKey = boxSealResponder(ecdhkey_ab_Responder_2,ecdhkey_AB_Responder,sign(skey_B_I_2,ecdhkey_ab_Responder_2)) in
    {67}out(ch_c2c, boxKeyResponder_1);
    {68}event evResponderSendboxKey(boxKeyResponder_1);
    {69}in(ch_c2c, OK_1: bitstring)
) | (
    {71}!
    {80}get step3_table_requester(ecdhkey_AB_Requester_1: sharedKey) in
    {73}let init_CK_Requester: chainKey = ecdhkey_AB_Requester_1 in
    {72}let Constant: nonce = uint64AsNonce(counter) in
    {74}let OKM: bitstring = HKDF(init_CK_Requester,Constant) in
    {75}let (nextCK_Requester: chainKey,MK: msgKey) = (fist256bit(OKM),next256bit(OKM)) in
    {76}let cipherTextRequester: bitstring = secretBoxSeal(plainTextRequester,Constant,MK) in
    {77}out(ch_c2c, (cipherTextRequester,counter));
    {78}event evRequesterSendcipherText(cipherTextRequester);
    {79}insert step6_table_requester(nextCK_Requester)
) | (
    {81}!
    {96}get step6_table_responder(ecdhkey_AB_Responder_1: sharedKey) in
    {82}in(ch_c2c, (cipherTextRequester_1: bitstring,counter_1: number));
    {83}event evResponderReceiveCipherText(cipherTextRequester_1);
    {85}let init_CK_Responder: chainKey = ecdhkey_AB_Responder_1 in
    {84}let Constant_1: nonce = uint64AsNonce(counter_1) in
    {86}let OKM_1: bitstring = HKDF(init_CK_Responder,Constant_1) in
    {87}let (next_CK_Responder: chainKey,MK_Responder: msgKey) = (fist256bit(OKM_1),next256bit(OKM_1)) in
    {89}let nextCounter: number = updateCounter(counter_1) in
    {90}let nextConstant: nonce = uint64AsNonce(nextCounter) in
    {91}let OKM_2: bitstring = HKDF(next_CK_Responder,nextConstant) in
    {92}let (next_next_CK_Responder: chainKey,nextMK: msgKey) = (fist256bit(OKM_2),next256bit(OKM_2)) in
    {93}let cipherTextResponder: bitstring = secretBoxSeal(plainTextResponder,nextConstant,nextMK) in
    {94}out(ch_c2c, (cipherTextResponder,nextCounter));
    {95}event evResponderSendCipherText(cipherTextResponder)
) | (
    {97}!
    {104}get step6_table_requester(nextCK_Requester_1: chainKey) in
    {98}in(ch_c2c, (cipherTextResponder_1: bitstring,newCounter: number));
    {99}let Constant_2: nonce = uint64AsNonce(newCounter) in
    {100}let OKM_3: bitstring = HKDF(nextCK_Requester_1,Constant_2) in
    {101}let (next_next_CK_Requester: chainKey,nextMK_Requester: msgKey) = (fist256bit(OKM_3),next256bit(OKM_3)) in
    {102}let plainTextResponder_1: bitstring = secretBoxOpen(cipherTextResponder_1,Constant_2,nextMK_Requester) in
    {103}event evRequesterReceiveCipherText(plainTextResponder_1)
)

-- Query event(evResponderHelloReceiveKey(pk_A_E_4)) ==> event(evRequesterHelloSendKey(pk_A_E_4)) in process 1.
Translating the process into Horn clauses...
Completing...
Starting query event(evResponderHelloReceiveKey(pk_A_E_4)) ==> event(evRequesterHelloSendKey(pk_A_E_4))
goal reachable: attacker(pk_A_E_4) -> event(evResponderHelloReceiveKey(pk_A_E_4))

Derivation:

1. We assume as hypothesis that
attacker(pk_A_E_4).

2. The message pk_A_E_4 that the attacker may have by 1 may be received at input {15}.
So event evResponderHelloReceiveKey(pk_A_E_4) may be executed at {16}.
event(evResponderHelloReceiveKey(pk_A_E_4)).

3. By 2, event(evResponderHelloReceiveKey(pk_A_E_4)).
The goal is reached, represented in the following fact:
event(evResponderHelloReceiveKey(pk_A_E_4)).


A more detailed output of the traces is available with
  set traceDisplay = long.

new skey_A_I: privateKey creating skey_A_I_4 at {1}

new skey_B_I: privateKey creating skey_B_I_3 at {2}

in(ch_s2c, a) at {15} in copy a_1

event evResponderHelloReceiveKey(a) at {16} in copy a_1 (goal)

The event evResponderHelloReceiveKey(a) is executed at {16} in copy a_1.
A trace has been found.
RESULT event(evResponderHelloReceiveKey(pk_A_E_4)) ==> event(evRequesterHelloSendKey(pk_A_E_4)) is false.
-- Query event(evResponderCalcPublicKey(pk_A_I_4)) ==> event(evRequesterSealPublicKey(pk_A_I_4)) in process 1.
Translating the process into Horn clauses...
Completing...
Starting query event(evResponderCalcPublicKey(pk_A_I_4)) ==> event(evRequesterSealPublicKey(pk_A_I_4))
goal reachable: attacker(boxKeyRequester_2) && attacker(pk_A_E_4) -> event(evResponderCalcPublicKey(unboxSeal(sca(skey_B_E_1,pk_A_E_4),sca(skey_B_I[],pk_A_E_4),boxKeyRequester_2)))
Abbreviations:
skey_B_E_1 = skey_B_E[pk_A_E_3 = pk_A_E_4,!1 = @sid]

Derivation:
Abbreviations:
skey_B_E_1 = skey_B_E[pk_A_E_3 = pk_A_E_4,!1 = @sid]

1. We assume as hypothesis that
attacker(pk_A_E_4).

2. The message pk_A_E_4 that the attacker may have by 1 may be received at input {15}.
So the entry step1_table_responder(pk_A_E_4) may be inserted in a table at insert {17}.
table(step1_table_responder(pk_A_E_4)).

3. The entry step1_table_responder(pk_A_E_4) that may be in a table by 2 may be read at get {30}.
So the entry step2_table_responder(sca(skey_B_E_1,pk_A_E_4),sca(skey_B_I[],pk_A_E_4),skey_B_I[]) may be inserted in a table at insert {29}.
table(step2_table_responder(sca(skey_B_E_1,pk_A_E_4),sca(skey_B_I[],pk_A_E_4),skey_B_I[])).

4. We assume as hypothesis that
attacker(boxKeyRequester_2).

5. The entry step2_table_responder(sca(skey_B_E_1,pk_A_E_4),sca(skey_B_I[],pk_A_E_4),skey_B_I[]) that may be in a table by 3 may be read at get {70}.
The message boxKeyRequester_2 that the attacker may have by 4 may be received at input {59}.
So event evResponderCalcPublicKey(unboxSeal(sca(skey_B_E_1,pk_A_E_4),sca(skey_B_I[],pk_A_E_4),boxKeyRequester_2)) may be executed at {61}.
event(evResponderCalcPublicKey(unboxSeal(sca(skey_B_E_1,pk_A_E_4),sca(skey_B_I[],pk_A_E_4),boxKeyRequester_2))).

6. By 5, event(evResponderCalcPublicKey(unboxSeal(sca(skey_B_E_1,pk_A_E_4),sca(skey_B_I[],pk_A_E_4),boxKeyRequester_2))).
The goal is reached, represented in the following fact:
event(evResponderCalcPublicKey(unboxSeal(sca(skey_B_E_1,pk_A_E_4),sca(skey_B_I[],pk_A_E_4),boxKeyRequester_2))).


A more detailed output of the traces is available with
  set traceDisplay = long.

new skey_A_I: privateKey creating skey_A_I_4 at {1}

new skey_B_I: privateKey creating skey_B_I_3 at {2}

in(ch_s2c, a) at {15} in copy a_1

event evResponderHelloReceiveKey(a) at {16} in copy a_1

insert step1_table_responder(a) at {17} in copy a_1

get step1_table_responder(a) at {30} in copy a_2

new skey_B_E: privateKey creating skey_B_E_2 at {20} in copy a_2

event evResponderHelloSendKey(pk(skey_B_E_2)) at {23} in copy a_2

out(ch_c2s, (~M,~M_1)) with ~M = pk(skey_B_I_3), ~M_1 = pk(skey_B_E_2) at {24} in copy a_2

event evResponderCalcShareSecret(sca(skey_B_E_2,a),sca(skey_B_I_3,a)) at {28} in copy a_2

insert step2_table_responder(sca(skey_B_E_2,a),sca(skey_B_I_3,a),skey_B_I_3) at {29} in copy a_2

get step2_table_responder(sca(skey_B_E_2,a),sca(skey_B_I_3,a),skey_B_I_3) at {70} in copy a_3

in(ch_c2c, a_4) at {59} in copy a_3

event evResponderCalcPublicKey(unboxSeal(sca(skey_B_E_2,a),sca(skey_B_I_3,a),a_4)) at {61} in copy a_3 (goal)

The event evResponderCalcPublicKey(unboxSeal(sca(skey_B_E_2,a),sca(skey_B_I_3,a),a_4)) is executed at {61} in copy a_3.
A trace has been found.
RESULT event(evResponderCalcPublicKey(pk_A_I_4)) ==> event(evRequesterSealPublicKey(pk_A_I_4)) is false.
-- Query event(evResponderCalcShareSecret(SharedSecret_ab,SharedSecret_aB)) ==> event(evRequesterHelloSendKey(pk_A_E_4)) in process 1.
Translating the process into Horn clauses...
Completing...
Starting query event(evResponderCalcShareSecret(SharedSecret_ab,SharedSecret_aB)) ==> event(evRequesterHelloSendKey(pk_A_E_4))
goal reachable: attacker(pk_A_E_4) -> event(evResponderCalcShareSecret(sca(skey_B_E_1,pk_A_E_4),sca(skey_B_I[],pk_A_E_4)))
Abbreviations:
skey_B_E_1 = skey_B_E[pk_A_E_3 = pk_A_E_4,!1 = @sid]

Derivation:
Abbreviations:
skey_B_E_1 = skey_B_E[pk_A_E_3 = pk_A_E_4,!1 = @sid]

1. We assume as hypothesis that
attacker(pk_A_E_4).

2. The message pk_A_E_4 that the attacker may have by 1 may be received at input {15}.
So the entry step1_table_responder(pk_A_E_4) may be inserted in a table at insert {17}.
table(step1_table_responder(pk_A_E_4)).

3. The entry step1_table_responder(pk_A_E_4) that may be in a table by 2 may be read at get {30}.
So event evResponderCalcShareSecret(sca(skey_B_E_1,pk_A_E_4),sca(skey_B_I[],pk_A_E_4)) may be executed at {28}.
event(evResponderCalcShareSecret(sca(skey_B_E_1,pk_A_E_4),sca(skey_B_I[],pk_A_E_4))).

4. By 3, event(evResponderCalcShareSecret(sca(skey_B_E_1,pk_A_E_4),sca(skey_B_I[],pk_A_E_4))).
The goal is reached, represented in the following fact:
event(evResponderCalcShareSecret(sca(skey_B_E_1,pk_A_E_4),sca(skey_B_I[],pk_A_E_4))).


A more detailed output of the traces is available with
  set traceDisplay = long.

new skey_A_I: privateKey creating skey_A_I_4 at {1}

new skey_B_I: privateKey creating skey_B_I_3 at {2}

in(ch_s2c, a) at {15} in copy a_1

event evResponderHelloReceiveKey(a) at {16} in copy a_1

insert step1_table_responder(a) at {17} in copy a_1

get step1_table_responder(a) at {30} in copy a_2

new skey_B_E: privateKey creating skey_B_E_2 at {20} in copy a_2

event evResponderHelloSendKey(pk(skey_B_E_2)) at {23} in copy a_2

out(ch_c2s, (~M,~M_1)) with ~M = pk(skey_B_I_3), ~M_1 = pk(skey_B_E_2) at {24} in copy a_2

event evResponderCalcShareSecret(sca(skey_B_E_2,a),sca(skey_B_I_3,a)) at {28} in copy a_2 (goal)

The event evResponderCalcShareSecret(sca(skey_B_E_2,a),sca(skey_B_I_3,a)) is executed at {28} in copy a_2.
A trace has been found.
RESULT event(evResponderCalcShareSecret(SharedSecret_ab,SharedSecret_aB)) ==> event(evRequesterHelloSendKey(pk_A_E_4)) is false.
-- Query event(evResponderCalcShareSecret(SharedSecret_ab,SharedSecret_aB)) ==> event(evRequesterCalcShareSecret(SharedSecret_ab,SharedSecret_aB)) in process 1.
Translating the process into Horn clauses...
Completing...
Starting query event(evResponderCalcShareSecret(SharedSecret_ab,SharedSecret_aB)) ==> event(evRequesterCalcShareSecret(SharedSecret_ab,SharedSecret_aB))
goal reachable: attacker(pk_A_E_4) -> event(evResponderCalcShareSecret(sca(skey_B_E_1,pk_A_E_4),sca(skey_B_I[],pk_A_E_4)))
Abbreviations:
skey_B_E_1 = skey_B_E[pk_A_E_3 = pk_A_E_4,!1 = @sid]

Derivation:
Abbreviations:
skey_B_E_1 = skey_B_E[pk_A_E_3 = pk_A_E_4,!1 = @sid]

1. We assume as hypothesis that
attacker(pk_A_E_4).

2. The message pk_A_E_4 that the attacker may have by 1 may be received at input {15}.
So the entry step1_table_responder(pk_A_E_4) may be inserted in a table at insert {17}.
table(step1_table_responder(pk_A_E_4)).

3. The entry step1_table_responder(pk_A_E_4) that may be in a table by 2 may be read at get {30}.
So event evResponderCalcShareSecret(sca(skey_B_E_1,pk_A_E_4),sca(skey_B_I[],pk_A_E_4)) may be executed at {28}.
event(evResponderCalcShareSecret(sca(skey_B_E_1,pk_A_E_4),sca(skey_B_I[],pk_A_E_4))).

4. By 3, event(evResponderCalcShareSecret(sca(skey_B_E_1,pk_A_E_4),sca(skey_B_I[],pk_A_E_4))).
The goal is reached, represented in the following fact:
event(evResponderCalcShareSecret(sca(skey_B_E_1,pk_A_E_4),sca(skey_B_I[],pk_A_E_4))).


A more detailed output of the traces is available with
  set traceDisplay = long.

new skey_A_I: privateKey creating skey_A_I_4 at {1}

new skey_B_I: privateKey creating skey_B_I_3 at {2}

in(ch_s2c, a) at {15} in copy a_1

event evResponderHelloReceiveKey(a) at {16} in copy a_1

insert step1_table_responder(a) at {17} in copy a_1

get step1_table_responder(a) at {30} in copy a_2

new skey_B_E: privateKey creating skey_B_E_2 at {20} in copy a_2

event evResponderHelloSendKey(pk(skey_B_E_2)) at {23} in copy a_2

out(ch_c2s, (~M,~M_1)) with ~M = pk(skey_B_I_3), ~M_1 = pk(skey_B_E_2) at {24} in copy a_2

event evResponderCalcShareSecret(sca(skey_B_E_2,a),sca(skey_B_I_3,a)) at {28} in copy a_2 (goal)

The event evResponderCalcShareSecret(sca(skey_B_E_2,a),sca(skey_B_I_3,a)) is executed at {28} in copy a_2.
A trace has been found.
RESULT event(evResponderCalcShareSecret(SharedSecret_ab,SharedSecret_aB)) ==> event(evRequesterCalcShareSecret(SharedSecret_ab,SharedSecret_aB)) is false.
-- Query event(evResponderAuthenticateCalcSharedKey(SharedSecret_AB)) ==> event(evRequesterSendboxKey(boxKeyRequester_2)) in process 1.
Translating the process into Horn clauses...
Completing...
Starting query event(evResponderAuthenticateCalcSharedKey(SharedSecret_AB)) ==> event(evRequesterSendboxKey(boxKeyRequester_2))
goal reachable: attacker(boxKeyRequester_2) && attacker(pk_A_E_4) -> event(evResponderAuthenticateCalcSharedKey(sca(skey_B_I[],unboxSeal(sca(skey_B_E_1,pk_A_E_4),sca(skey_B_I[],pk_A_E_4),boxKeyRequester_2))))
Abbreviations:
skey_B_E_1 = skey_B_E[pk_A_E_3 = pk_A_E_4,!1 = @sid]

Derivation:
Abbreviations:
skey_B_E_1 = skey_B_E[pk_A_E_3 = pk_A_E_4,!1 = @sid]

1. We assume as hypothesis that
attacker(pk_A_E_4).

2. The message pk_A_E_4 that the attacker may have by 1 may be received at input {15}.
So the entry step1_table_responder(pk_A_E_4) may be inserted in a table at insert {17}.
table(step1_table_responder(pk_A_E_4)).

3. The entry step1_table_responder(pk_A_E_4) that may be in a table by 2 may be read at get {30}.
So the entry step2_table_responder(sca(skey_B_E_1,pk_A_E_4),sca(skey_B_I[],pk_A_E_4),skey_B_I[]) may be inserted in a table at insert {29}.
table(step2_table_responder(sca(skey_B_E_1,pk_A_E_4),sca(skey_B_I[],pk_A_E_4),skey_B_I[])).

4. We assume as hypothesis that
attacker(boxKeyRequester_2).

5. The entry step2_table_responder(sca(skey_B_E_1,pk_A_E_4),sca(skey_B_I[],pk_A_E_4),skey_B_I[]) that may be in a table by 3 may be read at get {70}.
The message boxKeyRequester_2 that the attacker may have by 4 may be received at input {59}.
So event evResponderAuthenticateCalcSharedKey(sca(skey_B_I[],unboxSeal(sca(skey_B_E_1,pk_A_E_4),sca(skey_B_I[],pk_A_E_4),boxKeyRequester_2))) may be executed at {63}.
event(evResponderAuthenticateCalcSharedKey(sca(skey_B_I[],unboxSeal(sca(skey_B_E_1,pk_A_E_4),sca(skey_B_I[],pk_A_E_4),boxKeyRequester_2)))).

6. By 5, event(evResponderAuthenticateCalcSharedKey(sca(skey_B_I[],unboxSeal(sca(skey_B_E_1,pk_A_E_4),sca(skey_B_I[],pk_A_E_4),boxKeyRequester_2)))).
The goal is reached, represented in the following fact:
event(evResponderAuthenticateCalcSharedKey(sca(skey_B_I[],unboxSeal(sca(skey_B_E_1,pk_A_E_4),sca(skey_B_I[],pk_A_E_4),boxKeyRequester_2)))).


A more detailed output of the traces is available with
  set traceDisplay = long.

new skey_A_I: privateKey creating skey_A_I_4 at {1}

new skey_B_I: privateKey creating skey_B_I_3 at {2}

in(ch_s2c, a) at {15} in copy a_1

event evResponderHelloReceiveKey(a) at {16} in copy a_1

insert step1_table_responder(a) at {17} in copy a_1

get step1_table_responder(a) at {30} in copy a_2

new skey_B_E: privateKey creating skey_B_E_2 at {20} in copy a_2

event evResponderHelloSendKey(pk(skey_B_E_2)) at {23} in copy a_2

out(ch_c2s, (~M,~M_1)) with ~M = pk(skey_B_I_3), ~M_1 = pk(skey_B_E_2) at {24} in copy a_2

event evResponderCalcShareSecret(sca(skey_B_E_2,a),sca(skey_B_I_3,a)) at {28} in copy a_2

insert step2_table_responder(sca(skey_B_E_2,a),sca(skey_B_I_3,a),skey_B_I_3) at {29} in copy a_2

get step2_table_responder(sca(skey_B_E_2,a),sca(skey_B_I_3,a),skey_B_I_3) at {70} in copy a_3

in(ch_c2c, a_4) at {59} in copy a_3

event evResponderCalcPublicKey(unboxSeal(sca(skey_B_E_2,a),sca(skey_B_I_3,a),a_4)) at {61} in copy a_3

event evResponderAuthenticateCalcSharedKey(sca(skey_B_I_3,unboxSeal(sca(skey_B_E_2,a),sca(skey_B_I_3,a),a_4))) at {63} in copy a_3 (goal)

The event evResponderAuthenticateCalcSharedKey(sca(skey_B_I_3,unboxSeal(sca(skey_B_E_2,a),sca(skey_B_I_3,a),a_4))) is executed at {63} in copy a_3.
A trace has been found.
RESULT event(evResponderAuthenticateCalcSharedKey(SharedSecret_AB)) ==> event(evRequesterSendboxKey(boxKeyRequester_2)) is false.
-- Query event(evResponderReceiveCipherText(cipherTextRequester_2)) ==> event(evRequesterSendcipherText(cipherTextRequester_2)) in process 1.
Translating the process into Horn clauses...
Completing...
Starting query event(evResponderReceiveCipherText(cipherTextRequester_2)) ==> event(evRequesterSendcipherText(cipherTextRequester_2))
goal reachable: attacker(cipherTextRequester_2) -> event(evResponderReceiveCipherText(cipherTextRequester_2))

Derivation:
Abbreviations:
skey_B_E_1 = skey_B_E[pk_A_E_3 = pk_A_E_4,!1 = @sid]

1. The attacker has some term pk_A_E_4.
attacker(pk_A_E_4).

2. The message pk_A_E_4 that the attacker may have by 1 may be received at input {15}.
So the entry step1_table_responder(pk_A_E_4) may be inserted in a table at insert {17}.
table(step1_table_responder(pk_A_E_4)).

3. The entry step1_table_responder(pk_A_E_4) that may be in a table by 2 may be read at get {30}.
So the entry step2_table_responder(sca(skey_B_E_1,pk_A_E_4),sca(skey_B_I[],pk_A_E_4),skey_B_I[]) may be inserted in a table at insert {29}.
table(step2_table_responder(sca(skey_B_E_1,pk_A_E_4),sca(skey_B_I[],pk_A_E_4),skey_B_I[])).

4. The attacker has some term boxKeyRequester_2.
attacker(boxKeyRequester_2).

5. The entry step2_table_responder(sca(skey_B_E_1,pk_A_E_4),sca(skey_B_I[],pk_A_E_4),skey_B_I[]) that may be in a table by 3 may be read at get {70}.
The message boxKeyRequester_2 that the attacker may have by 4 may be received at input {59}.
So the entry step6_table_responder(sca(skey_B_I[],unboxSeal(sca(skey_B_E_1,pk_A_E_4),sca(skey_B_I[],pk_A_E_4),boxKeyRequester_2))) may be inserted in a table at insert {65}.
table(step6_table_responder(sca(skey_B_I[],unboxSeal(sca(skey_B_E_1,pk_A_E_4),sca(skey_B_I[],pk_A_E_4),boxKeyRequester_2)))).

6. The attacker has some term counter_2.
attacker(counter_2).

7. We assume as hypothesis that
attacker(cipherTextRequester_2).

8. By 7, the attacker may know cipherTextRequester_2.
By 6, the attacker may know counter_2.
Using the function 2-tuple the attacker may obtain (cipherTextRequester_2,counter_2).
attacker((cipherTextRequester_2,counter_2)).

9. The entry step6_table_responder(sca(skey_B_I[],unboxSeal(sca(skey_B_E_1,pk_A_E_4),sca(skey_B_I[],pk_A_E_4),boxKeyRequester_2))) that may be in a table by 5 may be read at get {96}.
The message (cipherTextRequester_2,counter_2) that the attacker may have by 8 may be received at input {82}.
So event evResponderReceiveCipherText(cipherTextRequester_2) may be executed at {83}.
event(evResponderReceiveCipherText(cipherTextRequester_2)).

10. By 9, event(evResponderReceiveCipherText(cipherTextRequester_2)).
The goal is reached, represented in the following fact:
event(evResponderReceiveCipherText(cipherTextRequester_2)).


A more detailed output of the traces is available with
  set traceDisplay = long.

new skey_A_I: privateKey creating skey_A_I_4 at {1}

new skey_B_I: privateKey creating skey_B_I_3 at {2}

in(ch_s2c, a) at {15} in copy a_1

event evResponderHelloReceiveKey(a) at {16} in copy a_1

insert step1_table_responder(a) at {17} in copy a_1

get step1_table_responder(a) at {30} in copy a_2

new skey_B_E: privateKey creating skey_B_E_2 at {20} in copy a_2

event evResponderHelloSendKey(pk(skey_B_E_2)) at {23} in copy a_2

out(ch_c2s, (~M,~M_1)) with ~M = pk(skey_B_I_3), ~M_1 = pk(skey_B_E_2) at {24} in copy a_2

event evResponderCalcShareSecret(sca(skey_B_E_2,a),sca(skey_B_I_3,a)) at {28} in copy a_2

insert step2_table_responder(sca(skey_B_E_2,a),sca(skey_B_I_3,a),skey_B_I_3) at {29} in copy a_2

get step2_table_responder(sca(skey_B_E_2,a),sca(skey_B_I_3,a),skey_B_I_3) at {70} in copy a_3

in(ch_c2c, a_4) at {59} in copy a_3

event evResponderCalcPublicKey(unboxSeal(sca(skey_B_E_2,a),sca(skey_B_I_3,a),a_4)) at {61} in copy a_3

event evResponderAuthenticateCalcSharedKey(sca(skey_B_I_3,unboxSeal(sca(skey_B_E_2,a),sca(skey_B_I_3,a),a_4))) at {63} in copy a_3

insert step3_table_responder(sca(skey_B_E_2,a),sca(skey_B_I_3,unboxSeal(sca(skey_B_E_2,a),sca(skey_B_I_3,a),a_4)),skey_B_I_3) at {64} in copy a_3

insert step6_table_responder(sca(skey_B_I_3,unboxSeal(sca(skey_B_E_2,a),sca(skey_B_I_3,a),a_4))) at {65} in copy a_3

out(ch_c2c, ~M_2) with ~M_2 = boxSealResponder(sca(skey_B_E_2,a),sca(skey_B_I_3,unboxSeal(sca(skey_B_E_2,a),sca(skey_B_I_3,a),a_4)),sign(skey_B_I_3,sca(skey_B_E_2,a))) at {67} in copy a_3

event evResponderSendboxKey(boxSealResponder(sca(skey_B_E_2,a),sca(skey_B_I_3,unboxSeal(sca(skey_B_E_2,a),sca(skey_B_I_3,a),a_4)),sign(skey_B_I_3,sca(skey_B_E_2,a)))) at {68} in copy a_3

get step6_table_responder(sca(skey_B_I_3,unboxSeal(sca(skey_B_E_2,a),sca(skey_B_I_3,a),a_4))) at {96} in copy a_5

in(ch_c2c, (a_6,a_7)) at {82} in copy a_5

event evResponderReceiveCipherText(a_6) at {83} in copy a_5 (goal)

The event evResponderReceiveCipherText(a_6) is executed at {83} in copy a_5.
A trace has been found.
RESULT event(evResponderReceiveCipherText(cipherTextRequester_2)) ==> event(evRequesterSendcipherText(cipherTextRequester_2)) is false.
-- Query event(evRequesterReceiveCipherText(plainTextResponder_2)) ==> event(evResponderSendCipherText(cipherTextRequester_2)) in process 1.
Translating the process into Horn clauses...
Completing...
Starting query event(evRequesterReceiveCipherText(plainTextResponder_2)) ==> event(evResponderSendCipherText(cipherTextRequester_2))
goal reachable: attacker(cipherTextResponder_2) && attacker(newCounter_1) && attacker(pk_B_I_4) -> event(evRequesterReceiveCipherText(secretBoxOpen(cipherTextResponder_2,uint64AsNonce(newCounter_1),next256bit(HKDF(fist256bit(HKDF(sca(skey_A_I[],pk_B_I_4),uint64AsNonce(counter))),uint64AsNonce(newCounter_1))))))

Derivation:
Abbreviations:
skey_A_E_2 = skey_A_E[!1 = @sid]

1. The entry step1_table_requester(skey_A_I[],skey_A_E_2) may be inserted in a table at insert {10}.
table(step1_table_requester(skey_A_I[],skey_A_E_2)).

2. The attacker has some term pk_B_E_3.
attacker(pk_B_E_3).

3. We assume as hypothesis that
attacker(pk_B_I_4).

4. By 3, the attacker may know pk_B_I_4.
By 2, the attacker may know pk_B_E_3.
Using the function 2-tuple the attacker may obtain (pk_B_I_4,pk_B_E_3).
attacker((pk_B_I_4,pk_B_E_3)).

5. The entry step1_table_requester(skey_A_I[],skey_A_E_2) that may be in a table by 1 may be read at get {43}.
The message (pk_B_I_4,pk_B_E_3) that the attacker may have by 4 may be received at input {35}.
So the entry step2_table_requester(sca(skey_A_E_2,pk_B_E_3),sca(skey_A_E_2,pk_B_I_4),pk(skey_A_I[]),skey_A_I[],pk_B_I_4) may be inserted in a table at insert {42}.
table(step2_table_requester(sca(skey_A_E_2,pk_B_E_3),sca(skey_A_E_2,pk_B_I_4),pk(skey_A_I[]),skey_A_I[],pk_B_I_4)).

6. The entry step2_table_requester(sca(skey_A_E_2,pk_B_E_3),sca(skey_A_E_2,pk_B_I_4),pk(skey_A_I[]),skey_A_I[],pk_B_I_4) that may be in a table by 5 may be read at get {57}.
So the entry step3_table_requester(sca(skey_A_I[],pk_B_I_4)) may be inserted in a table at insert {51}.
table(step3_table_requester(sca(skey_A_I[],pk_B_I_4))).

7. The entry step3_table_requester(sca(skey_A_I[],pk_B_I_4)) that may be in a table by 6 may be read at get {80}.
So the entry step6_table_requester(fist256bit(HKDF(sca(skey_A_I[],pk_B_I_4),uint64AsNonce(counter)))) may be inserted in a table at insert {79}.
table(step6_table_requester(fist256bit(HKDF(sca(skey_A_I[],pk_B_I_4),uint64AsNonce(counter))))).

8. We assume as hypothesis that
attacker(newCounter_1).

9. We assume as hypothesis that
attacker(cipherTextResponder_2).

10. By 9, the attacker may know cipherTextResponder_2.
By 8, the attacker may know newCounter_1.
Using the function 2-tuple the attacker may obtain (cipherTextResponder_2,newCounter_1).
attacker((cipherTextResponder_2,newCounter_1)).

11. The entry step6_table_requester(fist256bit(HKDF(sca(skey_A_I[],pk_B_I_4),uint64AsNonce(counter)))) that may be in a table by 7 may be read at get {104}.
The message (cipherTextResponder_2,newCounter_1) that the attacker may have by 10 may be received at input {98}.
So event evRequesterReceiveCipherText(secretBoxOpen(cipherTextResponder_2,uint64AsNonce(newCounter_1),next256bit(HKDF(fist256bit(HKDF(sca(skey_A_I[],pk_B_I_4),uint64AsNonce(counter))),uint64AsNonce(newCounter_1))))) may be executed at {103}.
event(evRequesterReceiveCipherText(secretBoxOpen(cipherTextResponder_2,uint64AsNonce(newCounter_1),next256bit(HKDF(fist256bit(HKDF(sca(skey_A_I[],pk_B_I_4),uint64AsNonce(counter))),uint64AsNonce(newCounter_1)))))).

12. By 11, event(evRequesterReceiveCipherText(secretBoxOpen(cipherTextResponder_2,uint64AsNonce(newCounter_1),next256bit(HKDF(fist256bit(HKDF(sca(skey_A_I[],pk_B_I_4),uint64AsNonce(counter))),uint64AsNonce(newCounter_1)))))).
The goal is reached, represented in the following fact:
event(evRequesterReceiveCipherText(secretBoxOpen(cipherTextResponder_2,uint64AsNonce(newCounter_1),next256bit(HKDF(fist256bit(HKDF(sca(skey_A_I[],pk_B_I_4),uint64AsNonce(counter))),uint64AsNonce(newCounter_1)))))).


A more detailed output of the traces is available with
  set traceDisplay = long.

new skey_A_I: privateKey creating skey_A_I_4 at {1}

new skey_B_I: privateKey creating skey_B_I_3 at {2}

new skey_A_E: privateKey creating skey_A_E_3 at {5} in copy a

event evRequesterHelloSendKey(pk(skey_A_E_3)) at {8} in copy a

out(ch_c2s, ~M) with ~M = pk(skey_A_E_3) at {9} in copy a

insert step1_table_requester(skey_A_I_4,skey_A_E_3) at {10} in copy a

get step1_table_requester(skey_A_I_4,skey_A_E_3) at {43} in copy a_1

in(ch_s2c, (a_2,a_3)) at {35} in copy a_1

event evResponderHelloReceiveKey(a_2) at {36} in copy a_1

event evResponderHelloReceiveKey(a_3) at {37} in copy a_1

event evRequesterCalcShareSecret(sca(skey_A_E_3,a_3),sca(skey_A_E_3,a_2)) at {40} in copy a_1

insert step2_table_requester(sca(skey_A_E_3,a_3),sca(skey_A_E_3,a_2),pk(skey_A_I_4),skey_A_I_4,a_2) at {42} in copy a_1

get step2_table_requester(sca(skey_A_E_3,a_3),sca(skey_A_E_3,a_2),pk(skey_A_I_4),skey_A_I_4,a_2) at {57} in copy a_4

event evRequesterSealPublicKey(pk(skey_A_I_4)) at {46} in copy a_4

out(ch_c2c, ~M_1) with ~M_1 = boxSeal(sca(skey_A_E_3,a_3),sca(skey_A_E_3,a_2),pk(skey_A_I_4),sign(skey_A_I_4,sca(skey_A_E_3,a_3))) at {47} in copy a_4

event evRequesterSendboxKey(boxSeal(sca(skey_A_E_3,a_3),sca(skey_A_E_3,a_2),pk(skey_A_I_4),sign(skey_A_I_4,sca(skey_A_E_3,a_3)))) at {48} in copy a_4

event evRequesterAuthenticateCalcSharedKey(sca(skey_A_I_4,a_2)) at {50} in copy a_4

insert step3_table_requester(sca(skey_A_I_4,a_2)) at {51} in copy a_4

get step3_table_requester(sca(skey_A_I_4,a_2)) at {80} in copy a_5

out(ch_c2c, (~M_2,~M_3)) with ~M_2 = secretBoxSeal(plainTextRequester,uint64AsNonce(counter),next256bit(HKDF(sca(skey_A_I_4,a_2),uint64AsNonce(counter)))), ~M_3 = counter at {77} in copy a_5

event evRequesterSendcipherText(secretBoxSeal(plainTextRequester,uint64AsNonce(counter),next256bit(HKDF(sca(skey_A_I_4,a_2),uint64AsNonce(counter))))) at {78} in copy a_5

insert step6_table_requester(fist256bit(HKDF(sca(skey_A_I_4,a_2),uint64AsNonce(counter)))) at {79} in copy a_5

get step6_table_requester(fist256bit(HKDF(sca(skey_A_I_4,a_2),uint64AsNonce(counter)))) at {104} in copy a_6

in(ch_c2c, (a_7,a_8)) at {98} in copy a_6

event evRequesterReceiveCipherText(secretBoxOpen(a_7,uint64AsNonce(a_8),next256bit(HKDF(fist256bit(HKDF(sca(skey_A_I_4,a_2),uint64AsNonce(counter))),uint64AsNonce(a_8))))) at {103} in copy a_6 (goal)

The event evRequesterReceiveCipherText(secretBoxOpen(a_7,uint64AsNonce(a_8),next256bit(HKDF(fist256bit(HKDF(sca(skey_A_I_4,a_2),uint64AsNonce(counter))),uint64AsNonce(a_8))))) is executed at {103} in copy a_6.
A trace has been found.
RESULT event(evRequesterReceiveCipherText(plainTextResponder_2)) ==> event(evResponderSendCipherText(cipherTextRequester_2)) is false.
-- Query not attacker(plainTextRequester[]) in process 1.
Translating the process into Horn clauses...
Completing...
Starting query not attacker(plainTextRequester[])
RESULT not attacker(plainTextRequester[]) is true.
-- Query not attacker(plainTextResponder[]) in process 1.
Translating the process into Horn clauses...
Completing...
Starting query not attacker(plainTextResponder[])
RESULT not attacker(plainTextResponder[]) is true.

--------------------------------------------------------------
Verification summary:

Query event(evResponderHelloReceiveKey(pk_A_E_4)) ==> event(evRequesterHelloSendKey(pk_A_E_4)) is false.

Query event(evResponderCalcPublicKey(pk_A_I_4)) ==> event(evRequesterSealPublicKey(pk_A_I_4)) is false.

Query event(evResponderCalcShareSecret(SharedSecret_ab,SharedSecret_aB)) ==> event(evRequesterHelloSendKey(pk_A_E_4)) is false.

Query event(evResponderCalcShareSecret(SharedSecret_ab,SharedSecret_aB)) ==> event(evRequesterCalcShareSecret(SharedSecret_ab,SharedSecret_aB)) is false.

Query event(evResponderAuthenticateCalcSharedKey(SharedSecret_AB)) ==> event(evRequesterSendboxKey(boxKeyRequester_2)) is false.

Query event(evResponderReceiveCipherText(cipherTextRequester_2)) ==> event(evRequesterSendcipherText(cipherTextRequester_2)) is false.

Query event(evRequesterReceiveCipherText(plainTextResponder_2)) ==> event(evResponderSendCipherText(cipherTextRequester_2)) is false.

Query not attacker(plainTextRequester[]) is true.

Query not attacker(plainTextResponder[]) is true.

--------------------------------------------------------------

